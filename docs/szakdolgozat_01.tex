% !TeX spellcheck = hu_HU
\documentclass[12pt, twoside]{report}
\usepackage[utf8]{inputenc}
\usepackage[magyar]{babel}
\usepackage[inner=3.5cm, outer=2.5cm, top=2.5cm, bottom=2.5cm]{geometry}
\usepackage{graphicx}
\linespread{1.5}

\hyphenation{Spacechess Position Player Figure Game History Judge Board Piece GameEvent King Queen Knight Bishop Unicorn Pawn Rook EventQueue Event GameController Controller Model View BoardPainter PanelPainter Widget}

% Title Page
\title{Térsakk}
\author{Máté Gergely}


\begin{document}

% % %
\begin{titlepage}
	\thispagestyle{empty}
	
	\begin{minipage}{0.30\linewidth}
		\includegraphics[scale=0.4]{eltecimer.eps}
	\end{minipage}
	\begin{minipage}{0.50\linewidth}
		\begin{center}
			Eötvös Loránd Tudományegyetem \\
			Informatikai Kar\\
			Programozási Nyelvek és Fordítóprogramok Tanszék
		\end{center}
	\end{minipage}
	
	
	\vspace{7cm}
	
	\begin{center}
		\Huge
		\textbf{Térsakk}
		\normalsize
	\end{center}
	
	\vspace{5.4cm}
	
	
	\begin{minipage}{0.5\linewidth}
		\textbf{Pataki Norbert}\\
		Adjunktus
	\end{minipage}
	\begin{minipage}{0.5\linewidth}
		\textbf{Máté Gergely}\\
		Programtervező Informatikus BSc
	\end{minipage}
	
	\vspace{4cm}
	
	\begin{center}
		Budapest, 2015
	\end{center}
	
\end{titlepage}

% % %
\tableofcontents

\chapter{Bevezető}

A Térsakk olyan sakkvariáns, amelyben a játéktábla két dimenziója kiegészül egy harmadikkal. Jómagam gyerekkorom óta szeretek sakkozni, felnőttkoromra ez egyik kedvenc hobbimmá, szenvedélyemmé vált. A Térsakkban a bábuk kilépnek a síkból, és nagyon izgalmas térbeli mozgáslehetőségek, különleges kombinációk jelennek meg. 

Gyerekkorom másik szenvedélye a számítógépes játékok játszása volt, ebből eredően tizenéves korom óta magamban hordozom az igényt, hogy magam is készítsek számítógépes játékot. A Térsakk a tábla szerkezetéből adódóan igen nehezen játszható valódi sakk-készlettel; még ha ügyes barkácsember el is készítheti az emeletes sakktáblát, a lépések kivitelezése, szabályosságának biztosítása nehéz feladat. A számítógép erre a feladatra különösen alkalmas, ezért döntöttem úgy, hogy ezt a játékot valósítom meg szakdolgozati témám gyanánt.

Célomul azt tűztem ki, hogy elkészítem a Térsakk játék számítógépen játszható változatát. 

\section{A Térsakk rövid története}
A Térsakkot - eredeti nevén, németül: Raumschach - Dr. Ferdinand Maack találta fel 1907-ben  \cite{chessvariants}. Maack a nyugati világban addigra széles körben elterjedt hagyományos sakkjátékot szerette volna kiterjeszteni három dimenzióra. Eleinte $ 8 \times 8 \times 8 $ mezőből álló táblával kísérletezett, egy erre a célra kialakított polcon egymás fölé helyezett nyolc hagyományos sakktáblát. Ekkor azonban 512 mezőből áll a tábla, és mivel játékosonként csak 32 bábu van, a bábuk aránya a mezők számához viszonyítva mindössze 1:8 - szemben a hagyományos sakk 1:2 arányával. Mivel ez nagyon lassú játékhoz vezet, Maack később arra jutott, hogy az $ 5 \times 5 \times 5 $-ös táblaméret kellemesebb játékot eredményez. Ekkor játékosonként 20 bábu van a táblán, és a bábuk aránya a mezők számához viszonyítva 1:3.125-höz. A második világháborúig bezárólag még Raumschach-klub is működött Hamburgban, azonban ezután a játék - feltehetően a nehézkes fizikai megvalósítás miatt - feledésbe merült.

\section{A játék szabályai, menete}
A Térsakk a hagyományos sakk kiterjesztése térbeli táblára. Dolgozatomban a hagyományos sakk szabályait ismertnek tekintem, mivel ezen a téren rengeteg kiváló irodalom áll rendelkezésre. A játékmenet a hagyományos sakkéval megegyezik, világos kezd, világos és sötét felváltva lépnek, és a játék célja az ellenfél királyának bemattolása. Ezért a Térsakk szabályainak ismertetése kapcsán a hagyományos sakktól való eltérésekre koncentrálok.

\subsection{Tábla, jelölés}
A Térsakk egy $ 5 \times 5 \times 5 $ "mezőből" álló kockában játszódik. Ezt úgy is elképzelhetjük, mintha készítenénk öt darab $ 5 \times 5 $-ös sík sakktáblát, és egymás fölé helyeznénk azokat. A figurák egy adott mezőről nem csak az adott síkbeli mezőkre léphetnek, hanem például a mező fölötti, illetve alatti mezőkre is. A mezők jelölése hasonló a hagyományos sakkéhoz, azonban kiegészül a \textbf{szint} jelölésével: az egymás fölötti sakktáblákat lentről felfelé az A, B, C, D, E (nagy)betűkkel jelöljük. Az egyes szinteken belül a \textbf{vonal}at balról jobbra a, b, c, d, e (kis)betűk jelölik, a \textbf{sor}okat pedig a világos oldaltól távolodva az 1, 2, 3, 4, 5 számok. Így például kezdetben a világos bástyáit tartalmazó mezők az Aa1 és Ae1 mezők, míg sötét bástyái a kocka átellenes sarkaiban, az Ea5 és Ee5 mezőkön állnak.

\subsection{Kezdőállás}
A játékban mindkét játékosnak 20-20 báb áll a rendelkezésére. Ezek az \textit{unikornis} kivételével a hagyományos sakkból ismert bábok. Világos bábui az alsó két szinten (A, B), az első két soron (1, 2) helyezkednek el. A második soron csak gyalogok állnak. Az A szint első sorában áll balról jobbra egy bástya, egy huszár, a király, a másik huszár, a másik bástya. A B szint első sorában aszimmetrikusan helyezkednek el a bábok, hogy a futók különböző alapszínre (világos és sötét mezőre is) kerüljenek. Itt a világos mezőn álló futó, egy unikornis, a vezér, a sötét mezőn álló futó és még egy unikornis követik egymást.

Sötét bábjai a felső két szinten (D és E), az utolsó két soron (4, 5) kezdenek. A negyedik soron - mintegy védőfalként a tisztek előtt - csak gyalogok állnak. Az E szint ötödik során a világoséval megegyező sorrendben helyezkednek el a két sötét bástya, a két sötét huszár és a sötét király. A D szint ötödik során sötét bábjai szintén tükrözik a világoséit, vagyis balról jobbra a világos mezőn álló futó, egy unikornis, a vezér, a sötét mezőn álló futó, és még egy unikornis következik.

Némileg meglepő lehet - a játéktér térbeli felépítéséből és a kezdőállásból következik - hogy a vezérsor bábjai már a játék elején, gyaloglépés nélkül is képesek az ellenfél gyalogjait azonnal leütni.

\subsection{Bábuk, lépések}

\subsubsection{A király}

A király az összes körülötte lévő mezőre léphet. Ez nem csak az adott szinten lévő szomszédos (oldallal vagy sarokkal érintkező) mezőket jelenti, hanem az eggyel lejjebbi illetve feljebbi szinteken lévő szomszédos mezőket is. Ez a tábla belsejében szabadon álló király esetén 26 mezőt jelent (9 egy szinttel feljebb, 8 az adott szinten, 9 egy szinttel lejjebb). A hagyományos sakkhoz hasonlóan nem léphetünk úgy, hogy a királyunk sakkba kerüljön. Sáncolni nem lehetséges.

\subsubsection{A vezér}

A vezér a Térsakk legerősebb bábja. A hagyományos sakkhoz hasonlóan tetszőleges számú mezőt haladhat egy adott irányba. Ez az irány lehet egyenes (mint a bástya), vagy egy sík mentén átlós (mint a futó), vagy akár a kocka átlójával párhuzamosan átlós (mint az unikornis).

\subsubsection{A bástya}

A bástya a tábla adta koordináta-rendszer három tengelyével párhuzamos irányokba tetszőleges számú mezőt mehet előre. Ez a tábla belsejében szabadon álló bástya esetén hat irányt jelent, a hagyományos sakk irányai kiegészülnek a fel- illetve lefelé történő mozgással. Amennyiben egy mezőre kockaként tekintünk, a bástya mindig a kocka oldallapján halad keresztül.

\subsubsection{Az unikornis}

Az unikornis a kocka átlóival párhuzamos irányokba tetszőleges számú lépést tehet. Ez a tábla belsejében szabadon álló unikornis esetén nyolc irányt jelent. Amennyiben egy mezőre kockaként tekintünk, az unikornis mindig a kocka csúcsain halad át.

\subsubsection{A futó}

A futó a hagyományos sakkhoz hasonlóan, síkban átlósan mozog. Mivel egy mezőt három sík is tartalmaz (vízszintesen az egyes szintek, függőlegesen az egyes vonalak és az egyes sorok által meghatározott síkok), egy a tábla belsejében szabadon álló futó 12 irányba indulhat el. Amennyiben egy mezőre kockaként tekintünk, a futó azt a kocka összes élén keresztül hagyhatja el. 

\subsubsection{A huszár}

A huszár a hagyományos sakkhoz hasonlóan két lépést tesz egy adott irányba, majd egy lépést arra az irányra merőlegesen. Ez azonban a térbeli szerkezetből fakadóan hat kezdeti irányt, és a merőleges választásánál kezdeti irányonként négy további lehetőséget jelent. A huszár útja során a közben álló bábokat átugorja. 

\subsubsection{A gyalog}

A világos gyalogok a sötét alapvonalak felé, a sötét gyalogok a világos alapvonalak felé haladnak. Kezdeti kettős lépés a tábla kis mérete miatt nincs. Egy világos gyalog léphet előre (eggyel nagyobb számú sorba), vagy felfelé (egy szinttel feljebb). Ütni üthet az adott szinten átlósan előre, egy szinttel feljebb átlósan felfelé, valamint azonos vonalon maradva átlósan előre felfelé is. Sötét gyalogjai hasonlóan viselkednek, azonban világos alapsorai felé haladnak, vagyis adott szinten kisebb számú sorba, vagy pedig lefelé történhet a lépés. A gyalogok az ellenfél tisztjeinek alapsorait elérve vezérré változnak át.

\chapter{Felhasználói dokumentáció}

A Spacechess program segítségével Térsakkot lehet játszani a számítógépet használva tábla és bábuk helyett. A program lehetőséget ad rá, hogy két játékos ugyanazon számítógép előtt ülve megmérkőzzön egymással, továbbá arra is van lehetőség, hogy - TCP/IP hálózaton keresztül - két különböző számítógépről játsszanak egymás ellen. A program a befejeződött játszmákat elmenti, azok archiválhatóak és utólag visszanézhetőek. A szoftver platformfüggetlen, egyaránt futtatható GNU/Linux és Microsoft Windows operációs rendszerek alatt. A szoftver használatához grafikus környezetre és egérre (vagy más mutatóeszközre) van szükség.

\section{Telepítés}

A Spacechess program a "Spacechess" futtatható állományból, továbbá a bábok képét tartalmazó képfájlokból, illetve egy True Type Font betűtípus-leíró fájlból áll. Mindezeket egy közös mappába a számítógépre kell másolni. 

GNU/Linux operációs rendszer esetén a futtatáshoz szükséges, hogy a rendszerre az SFML multimédiás programkönyvtár minimálisan 2.1-es verziója telepítve legyen. Ubuntu rendszer esetén az SFML szükséges komponenseit a következő csomagok telepítésével biztosíthatjuk: libsfml-system2, libsfml-network2, libsfml-window2, libsfml-graphics2.

Microsoft Windows operációs rendszer esetén az SFML használatához szükséges DLL állományokat a Spacechess program mappájába kell elhelyezni (a mellékelt CD-n a mappa tartalmazza az állományokat). 

\section{Futtatás}	

Mivel a Spacechess program alapvetően GNU/Linux rendszerre lett fejlesztve, futtatása követi annak szemléletét, így a futtatás különböző módjait parancssori argumentumok megadásával lehet elérni. A programból minden üzemmódban a grafikus felület ablakának bezárásával léphetünk ki. A szoftver a következő módokon futtatható:
\subsection*{\tt Spacechess}
Argumentum megadása nélkül futtatva helyi játékot kezdünk, ahol mindkét játékos ugyanazon számítógép előtt ülve felváltva léphet.
\subsection*{\tt Spacechess -s [portszám]}
Az -s argumentum megadásával hálózati játékot kezdeményezhetünk, ilyenkor a program kiszolgáló üzemmódban indul el, és várja, hogy a szoftver egy másik példánya TCP/IP hálózaton keresztül csatlakozzon hozzá. Portszám megadása opcionális, alapértelmezésben az 54321 porton történik a csatlakozás.
\subsection*{\tt Spacechess -c [ipcím[:portszám]]}
A -c argumentum megadásával programunk csatlakozni próbál a szoftver egy másik példányához. Az "ipcím" paraméterrel adható meg a távoli számítógép hálózati címe (elhagyva a helyi számítógéphez próbál csatlakozni). A portszám megadása szintén opcionális, amennyiben nem az alapértelmezett hálózati porton szeretnék játszani, itt tudjuk az új portszámot megadni. Például a "{\tt Spacechess -c 192.168.0.2:4000}" parancs a 192.168.0.2 IP-címmel azonosított számítógép 4000-es számú portján keresi a kiszolgáló üzemmódban elindított Spacechess példányt, amit az adott számítógépen a "{\tt Spacechess -s 4000}" parancs segítségével indíthatunk el.
\subsection*{\tt Spacechess -r [fájlnév]}
Az -r argumentum segítségével visszajátszó üzemmódban indíthatjuk el a szoftvert. Alapértelmezésben a "lastspacechessgame.txt" állomány kerül megnyitásra, ez a fájlnév megadásával felülbírálható. A megadott állomány a Spacechess program által elmentett játszmaleíró fájl kell legyen.


\section{Játék egy számítógépen}

Amennyiben helyi játékot indítunk, megjelenik a grafikus felhasználói felület. A játékosok felváltva lépnek, világos kezd. 

\subsection{A játéktábla számítógépes megjelenítése}

A Spacechess program az $ 5 \times 5 \times 5 $ mezőből álló táblát 5 síktáblaként jeleníti meg. Azonban a síktáblák nem a kocka egyes szintjeit reprezentálják, hanem (balról jobbra haladva) a világos oldala felől nézve egymás után következő síkmetszeteket, vagyis a játéktábla sorait\footnote{A tábla térbeli szerkezetéből következik, hogy amit a hagyományos sakkban \textit{sor}nak nevezünk, az itt $ 5 \times 5 $ mezőt jelent: mind az 5 szinten egy-egy 5 mezőből álló sort.}. Így a képernyő bal oldalán megjelenő $ 5 \times 5 $ mezőből álló síktábla a világos színnel játszó játékoshoz legközelebb eső sorait tartalmazza a játéktáblának (a kocka legközelebbi szeletét). A képernyő jobb szélén található $ 5 \times 5 $ mezőből álló síktábla pedig a kocka legtávolabbi sorait, amelyen sötét tisztjei találhatóak az alapállásban. Így a képernyőn felfelé és lefelé mutató irány a térbeli sakktáblán is felfelé illetve lefelé mutat. 

A táblák fölött és mellett látható az eligazodást segítő jelölés ("ABCDE" a szintek, "abcde" a vonalak és "12345" a sorok jelölésére). Az egérmutatót az egyes mezők fölé mozgatva a tábla alatt megjelenik az adott mező jelölése (például Ac4 vagy Db3).

\subsection{A lépés}

Egérkattintás segítségével a soron következő játékos bábui kiválaszthatóak. Amennyiben a bábunak vannak lépési lehetőségei, ezek színezés segítségével megjelennek a táblán. Ha a játékos meggondolja magát, és inkább másik bábuval szeretne lépni, a korábban kiválasztott bábura ismét kattintva a kijelölés megszűnik, és ezután új báb választható. Amikor kijelöltünk egy bábut lépésre, majd egy átszínezett mezőre kattintunk, ahova a kijelölt bábu a játék szabályai szerint léphet, a lépés megtörténik, és ezután a másik játékos következik.

Nem lehet olyat lépni, aminek a következtében a királyunk sakkba kerülne, és ha a királyunk sakkban van, akkor lépésünkkel meg kell szüntessük a sakkot. Ha ez nem lehetséges, mattot kaptunk, ezt a program kijelzi. Amennyiben a királyunk nincsen sakkban, de semmilyen szabályos lépést nem tudunk tenni, ez patt, vagyis döntetlen, a program ezt is kijelzi\footnote{A hagyományos sakkban a patton kívül más módokon is létrejöhet döntetlen, például amennyiben ugyanaz az állás egymást követően háromszor létrejön a táblán, a bírótól döntetlen kérhető. Az ilyen döntetlenek lehetőségeivel a program nem foglalkozik.}.

Amennyiben egy gyalogunkkal belépünk az ellenfél tisztjeinek bázisára, gyalogunk automatikusan vezérré alakul át.

\section{Visszajátszás}

Bármikor, amikor egy játszma során bezárjuk az alkalmazást, az összes addigi lépés elmentésre kerül a "lastspacechessgame.txt" elnevezésű állományba. Ezt az állományt archiválási céllal átnevezhetjük, illetve az "-r" argumentummal indítva a programot a játszmát visszanézhetjük. A visszajátszás során megjelenik a grafikus felhasználói felület, a táblán a kezdőállással. A jobb oldali egérgombbal bárhol kattintva a játszma történetében egy lépést haladhatunk előre, vagyis megnézhetjük a következő lépés eredményét. A bal oldali egérgombbal kattintva az egy lépéssel korábbi állapotot kapjuk. Így oda-vissza végignézhetjük a játszma lépéseit.

\section{Játék hálózaton}

A hálózati játék során két, egymással TCP/IP hálózati kapcsolatban álló számítógépen két külön Spacechess program kommunikál. Ennek menete a következő:

Először elindítjuk a kiszolgálót az "-s" parancssori argumentummal. Megjelenik a grafikus felhasználói felület, és a program jelzi, hogy csatlakozásra vár.

Ekkor a másik játékos elindítja a csatlakozó szoftvert a "-c" argumentummal. Ha a csatlakozás sikeres, a játszma elindul. A csatlakozó játékos játszik világossal, így övé az első lépés. Amikor ezt megtette, a lépés megjelenik mindkét játékos számítógépén, és most sötéten a lépés sora. A lépés megtételének módja megegyezik a helyi játszmánál használható módozattal: a léptetni kívánt bábot kijelöljük, majd a célmezőre kattintunk, stb.

\chapter{Fejlesztői dokumentáció}

A Fejlesztői dokumentáció tartalmazza 
\begin{itemize}
\item a probléma részletes specifikációját, 
\item a felhasznált módszerek részletes leírását, a használt fogalmak definícióját,
\item a program logikai és fizikai szerkezetének leírását (adatszerkezetek, adatbázisok, modulfelbontás),
\item a tesztelési tervet és a tesztelés eredményeit.
\end{itemize}


\section{A szoftver informális specifikációja}

A szoftver célja, hogy a Térsakk játékot szimulálja, a Térsakk tábláját és bábuit virtuálisan megjelenítse, és segítségével két személy helyben egy számítógépen, vagy hálózaton keresztül két számítógépen Térsakk játszmákat játszhasson le. Célja továbbá, hogy a játszott játszmák archiválásra kerüljenek, és a szoftver segítségével visszanézhetőek legyenek.

Ezek a tevékenységek a felhasználó szemszögéből a következő UML diagramokkal írhatók le.

[ Felhasználói esetek diagramokkal ]

\section{A használt fejlesztői eszközök és módszerek}

\subsection{C++11}

A szoftver fejlesztése során elsődleges szempont volt, hogy a programot a lehető legtöbb számítógépen futtatni lehessen, vagyis a lehető legnagyobb mértékű platformfüggetlenség. Szempont volt továbbá a hatékonyság, hogy (jövőbeli fejlesztési lehetőségként) adott esetben kis számítási kapacitással rendelkező eszközökön (például mobiltelefonokon) is jól működjön a program. Ezért az implementáláshoz a C++ programozási nyelv 2011-es ISO szabványára (a továbbiakban C++11) esett a választás, mivel ez mind a széles körben elérhetőség, mind a hatékonyság követelményeinek megfelel. A program készítése során igyekeztem elsődlegesen a C++11 eszközeit használni, vagyis ha egy feladat megoldható a C++11 segítségével, akkor nem használtam harmadik fél által kínált programkönyvtárakat.

Ahogy haladtam a program fejlesztésével, a C++11 szabványnak egyre több szolgáltatását ismertem meg. A fejlesztés során igyekeztem folyamatosan hasznosítani az új ismereteket. Például míg eleinte konstruktorok segítségével inicializáltam a különböző objektumokat, később átálltam az egységes inicializáló-listák használatára. Vagy míg eleinte a \emph{new} kulcsszó segítségével inicializáltam a smart-pointereket, később átálltam a \emph{std::make\_shared\textless\textgreater()} sablonfüggvény használatára. Ennek köszönhetően azonban a C++ nyelv használata nem lett egységes a forrásszövegben, még a folyamatos refaktorálás ellenére sem.

\subsection{SFML}

Szintén a hatékonyság és a platformfüggetlenség kívánalmának akarván megfelelni, a grafikus felhasználói felület megvalósításához az OpenGl szabványra esett a választásom. Mivel azonban az OpenGl igényel valamilyen köztes réteget az alkalmazás és az operációs rendszer között (például önmagában nem tartalmaz ablakkezelést), a Simple and Fast Muldimedia Library (továbbiakban SFML) nyílt forráskódú programkönyvtár segítségéhez fordultam \cite{sfml}. Mint kiderült, az SFML erősen objektumorientált szemléletű, és azon túl, hogy lehetőséget ad OpenGl programok írására, önmagában is rendelkezik magasabb szintű grafikus képességekkel, amelyek a program elkészítéséhez elégnek bizonyultak. Így aztán az OpenGl közvetlen programozására az alkalmazásban nem is került sor. 

Az SFML azon túl, hogy biztosítja az ablakkezelést és egyszerű grafikus műveleteket, az egér kezelését is egyszerűvé teszi, továbbá tartalmaz egy hálózati modult, amivel az operációs rendszer hálózati szolgáltatásait elfedi. Így az operációs rendszer szolgáltatásait a fájlkezelést illetően a C++11 szabvány könyvtára, az összes többi szolgáltatást illetően pedig az SFML elfedi. Az SFML mind GNU/Linux, mind Microsoft Windows, mind Apple OS-X környezetben működik, így használatával a platformfüggetlenség nagy mértékben megvalósult, a Spacechess program forráskódja lényegében változtatások nélkül\footnote{Apróbb változtatásokra szükség lehet, mivel a különböző fordítóprogramok a C++11 szabványt különböző mértékben valósítják meg.} lefordítható az említett platformokon. 

\subsection{CMake}

Mivel a Spacechess program nagyszámú forrásfájlból áll, szükségem volt egy egységes, több platformon is működő \emph{build}-rendszerre, amely a forrásfájlokból a megfelelő bináris állományokat elkészíti. Erre a célra a nyílt forrású CMake rendszert használtam \cite{cmake}. A CMake egy úgynevezett meta-build rendszer. A forráskód mappáiban elhelyezett {\tt CMakeList.txt} állományok a CMake saját programnyelvén\footnote{A CMake programnyelve leginkább a shell scriptek nyelveihez hasonló.} leírják, hogy a forrásfájlokat hogyan kell lefordítani. A CMake program ez alapján készíti el az adott platform és fejlesztőkörnyezet egyedi build állományait, például GNU/Linux esetén \emph{Makefile} állományokat, vagy Microsoft Visual Studio esetén a fordítás szerkezetét leíró \emph{Solution}-t. Ezután az adott fejlesztőeszköz végzi el a fordítást.

A Spacechess program kapcsán a CMake elemi használatához elég azt tudni, hogy amennyiben új C++ forrásállományt ({\tt *.cpp}) hozunk létre, annak nevét a tartalmazó mappa {\tt CMakeList.txt} állmányában a \emph{SOURCES} változó értékeként fel kell sorolni a fordításhoz.

\subsection{Catch}

A szoftver fejlesztése során célszerűnek tűnt az egyes részek működését automatikus teszteléssel biztosítani. Ehhez szükségem volt egy könnyek kezelhető tesztelési keretrendszerre. Némi tájékozódás után a Catch nevű eszközre esett a választás \cite{catch}. A Catch egyetlen \emph{header} állományból áll, aminek következtében nagyon hamar üzembe tudtam állítani. A tesztfájlok a forráskód Tests almappájába kerültek, és első utasításként behívják a catch.hpp állományt. A tesztek lefordításához a forráskódhoz hasonlóan a CMake rendszer használatos. A fordítás során egy Tests nevű futtatható állomány keletkezik, amelyet végrehajtva az összes tesztünk ellenőrzésre kerül.

A tesztek forráskódja szabvány C++ szöveg néhány makróval kiegészítve. A SCENARIO makró segítségével teszteseteket adhatunk meg. A teszteseteken belül megadhatunk környezeteket a GIVEN, WHEN és THEN makrókkal, melyek azonos funkcionalitással bírnak, és tetszőleges mélységben egymásba ágyazhatóak. Az alacsonyabb szinten lévő környezetben történő változások egyáltalán nincsenek kihatással a magasabb szinten lévő környezetre, így azonos környezetet biztosíthatunk több különböző, egymás után végrehajtandó teszt számára, ha az előkészítést magasabb szinten, az egyes tesztesetek vizsgálatát alacsonyabb szinten végezzük el. Megadhatunk továbbá a programra vonatkozó logikai állításokat a REQUIRE makró paramétereként, ezek igaz volta kerül ellenőrzésre a teszt futtatása során.

A SCENARIO, GIVEN, THEN, WHEN makrók célja a Catch rendszerben a tesztvezérelt fejlesztés lehetővé tétele. Amennyiben erre nincs szükség, a Catch használata még egyszerűbb lehet. A SCENARIO makró helyett használható az azonos funkcionalitású TEST\_CASE makró, és a GIVEN, THEN, WHEN makrók helyettesíthetőek a SECTION makróval, amely tetszőleges mélységben tartalmazhat további SECTION makrókat. További tesztek készítéséhez ezt az egyszerűbb megközelítést javaslom.

\subsection{További felhasznált eszközök}

A fejlesztést elsődlegesen Ubuntu GNU/Linux rendszeren végeztem. Fejlesztői környezetnek a nagyszerű KDevelop integrált fejlesztőrendszert használtam. A sakkbábuk képfájljait az Inkscape program segítségével szabtam a program igényeihez. Az eredeti képfájlokat Uray Marcell János készítette és tette szabadon felhasználhatóvá. A programban használt betűtípus szintén szabadon felhasználható, és az SFML példaállományaiból származik. A Microsoft Windows alatt működő változat a Visual Studio Community 2013 verziójával került lefordításra.

\subsection{Módszertan}

A program fejlesztése során több fejlesztési és projekt-kivitelezési módszertant is kipróbáltam. Folyamatosan törekedtem az objektum-orientált fejlesztési elvek minél teljesebb elsajátítására. A fejlesztés iteratív folyamat volt, amelyben tervezési szakaszokat kódolási szakaszok váltottak. A tervezést többnyire UML diagramok készítése jelentette. A kódolási szakaszban a diagramok alapján készítettem kódot, azonban az eközben felmerülő problémákra már kódban kerestem megoldást. Amikor kezdtem elveszteni a tájékozódást a kódban, az alapján frissítettem az UML diagramokat, és ismét az UML szintjén végeztem a tervezést. Körülbelül nyolc ilyen tervezés-kódolás iterációt csináltam végig.

A projekt menedzselése során egy agilisnek tekinthető módszert, a SMART módszertant követtem. Ennek keretében két-három hetes időszakokra egyszerűbb, jól körülhatárolt, reálisan megvalósítandó célokat tűztünk ki a konzulensem segítségével, melyeket írásban rögzítettem. Bár a határidőket időnként nem sikerült tartanom, a módszer tervezhetősége folytán lehetőséget adott a korrekciókra.

Az agilis fejlesztési módszerek alkalmazásában nagyon nagy hatással volt rám Robert C. Martin Tiszta Kód című könyve \cite{cleancode}. Ennek eredményeképpen jelentek meg a kódban nagy számban a különböző részfeladatokat ellátó privát eljárások. Ennek köszönhető, hogy a kódban nagyon kevés megjegyzés maradt, helyettük a függvények és változók hosszú, beszédes neveket kaptak annak érdekében, hogy szerepük és funkciójuk megjegyzések nélkül is tisztán és világosan érthetővé váljon a kód olvasója számára. A programot folyamatosan refaktoráltam, hogy minél egyszerűbbé, minél érthetőbbé váljon a forráskód.

\section{A program logikai szerkezete}

A Spacechess program megvalósításához a Modell-Nézet-Vezérlő architektúrát választottam. A három modul kezdetben nagyon elvált egymástól, a Nézet csak a Vezérlőn keresztül kommunikált a Modellel. Ez nehézkesnek bizonyult, ezért létrehoztam a Modell számára egy csak olvasható interfészt, és a Nézet immár ezen keresztül közvetlenül is lekérheti a Modell állapotának részleteit. A három modul három különböző névtérben helyezkedik el.

\subsection{A vezérlés}

A {\tt main} függvény és az alkalmazás osztály kivételével az összes vezérlési osztály a Controller névtérben kapott helyet.

\subsubsection{A program belépési pontja}

A program belépési pontja a {\tt main} függvény, ami mindösszesen létrehoz egy alkalmazás (App) objektumot, és delegálja a parancssori paramétereket számára.

\subsubsection{Az App osztály}

Az App osztály létrehozza a grafikus felhasználói felület ablakát ({\tt setUpWindow} metódus), és a parancssori paraméterek függvényében a megfelelő vezérlő objektumot ({\tt setUpAGameController} metódus). Amennyiben a parancssori paraméterek nem megfelelőek, erről tájékoztatást ad ({\tt showUsage} metódus), majd a program kilép.

\subsubsection{A GameController osztály és leszármazottai}

A GameController osztály leszármazottai biztosítják a program különféle működési módjainak vezérlését. A LocalGameController a helyi játék lebonyolításáért felelős, a NetworkGameController a hálózati játék működtetéséért. A PlaybackController osztály szintén a GameController leszármazottja, a játszmák visszajátszásának vezérlését valósítja meg.

A GameController osztály öröklődő attribútuma a Modell játszmát leíró osztályának (Game) egy példánya, továbbá a Nézet grafikus megjelenítésért felelős osztályának (Render2D) egy példánya. A Vezérlő és a Nézet közötti belső üzenetküldésre használatos az EventQueue osztály által megvalósított, belső eseményeket leíró üzenetsor. 

A GameController osztály három absztrakt metódust tartalmaz. Ezek a {\tt mainLoop}, amelyben a vezérlési ciklust kell megvalósítani, a {\tt handleSystemEvents}, amely az SFML által közvetített rendszeresemények lekezelését szolgálja, és a {\tt handleGameEvents}, amelyben a belső üzenetsor (EventQueue) eseményeit kezeljük le. Az App osztály a GameController valamely leszármazottjának {\tt mainLoop} metódusának adja át a vezérlést.

\subsection {A játékmodell}

A játszmák logikai működését szimuláló Modell osztályai a Model névtérbe kerültek. A Modell a következő alapfogalmakkal dolgozik.

\subsubsection {Player}
A Player enumeráció segítségével a játékosokra lehet hivatkozni.

\subsubsection{Figure}
A Figure enumeráció a Térsakk játék különböző figuráit sorolja fel.

\subsubsection{Position}
A Position osztály a 3 dimenziós sakktábla egy mezőjét jelöli ki. Ezen túl lehetőséget nyújt a szomszédos pozíciók meghatározására egy adott mezőhöz képest az {\tt over, under, right, left, farther, closer} metódusok segítségével, mely irányok a világos játékos oldala felől értendőek. Ezek a metódusok egy új Position objektumot adnak vissza, ami ismét rendelkezik ilyen metódusokkal, tehát például egy huszár egy lehetséges lépését leírhatjuk a {\tt position.farther().farther().left()} kifejezéssel. Position objektumot létrehozhatunk úgy is, hogy számszerűen megadjuk, melyik szinten, melyik vonalon és melyik sorban legyen a pozíció, de az osztály túlterhelt konstruktora elfogadja a játékban használatos három jelből álló pozícióleírást (például "Cc3" vagy "Ad2") is egy sztringben. A Position osztály megvalósítja a $<$ összehasonlító operátort, hogy használható legyen rendezést kívánó szabványos konténerekben.

\subsubsection{A Piece osztály és leszármazottai}

A Piece egy absztrakt osztály, melynek leszármazottai  az egyes figurák viselkedését adják meg. A Piece osztály a statikus {\tt generatePiece} metódus segítségével generálja a különböző bábu-objektumokat. A {\tt generatePiece} metódus egy bábu-leíró sztringet és egy, a táblára mutató mutatót vár paraméterül. A bábu-leíró sztring formátuma a következő:
\begin{itemize}
	\item az első karakter kisbetűs 'w' vagy 'b' attól függően, hogy világos vagy sötét figurát szeretnénk,
	\item a második karakter a nagybetűs 'K', 'Q', 'R', 'B', 'N', 'U', 'P', amely rendre királyt, vezért, bástyát, futót, huszárt, unikornist és gyalogot jelöl,
	\item a következő három karakter a figura pozícióját adja meg a játéktábla jelölésével (például "Bc4" vagy "Ee5").
\end{itemize}
Amennyiben a bábu-leíró sztring formátuma hibás, invalid\_argument kivétel keletkezik.

A Pieceből származott objektumok ismerik a játékost, amelynek bábui ({\tt getPlayer}), meg tudják mondani, hogy hol helyezkednek el a táblán ({\tt getPosition}), és hogy milyen figurák ők ({\tt getFigure}). Ennél többet is tudnak azonban, meg tudják mondani, hogy mely mezőkre léphetnek ({\tt getPossibleMoves} metódus), illetve mely mezőkön tudnak ütni ({\tt getPossibleTakes} metódus). Ez utóbbi három metódust a leszármazottak értelemszerűen felüldefiniálhatják. Mivel a lehetséges lépések pozíciói csak a gyalog esetén térnek el a lehetséges ütések pozícióitól, a Piece osztály {\tt getPossibleTakes} metódusa közös, megfelelő alapértelmezett működést biztosít a többi figura számára.

Mivel a lehetséges lépések és ütések meghatározása során olyan tevékenységekre van szükség, amelyek kettő vagy több figura esetén megegyeznek, a Piece osztály nagyszámú védett segédfüggvényt bocsát a tőle öröklődő osztályok rendelkezésére. Ezek a következők:
\begin{itemize}
	\item A logikai értékkel visszatérő {\tt canMoveTo, canTakeAt, canMoveToOrTakeAt} függvények megadják, hogy egy adott pozíció üres-e, az ellenfél bábuját tartalmazza-e, illetve ezek közül valamelyik teljesül-e.
	\item A {\tt filterForOnBoard, filterForMove, filterForTake, filterForMoveOrTake} eljárások egy pozíciókból álló listát várnak paraméterül, és különböző feltételek szerint megszűrik azokat, vagyis a listáról kitörlik azokat a pozíciókat, amelyek nem felelnek meg egy adott feltételnek. 
		\subitem A {\tt filterForOnBoard} eljárás a táblára eső pozíciókat hagyja a listában. Erre azért van szükség, mert a pozíciók közötti navigálás során (a Position osztály {\tt over, under, left, right, farther, closer} metódusai segítségével) előfordulhat, hogy lemegyünk a tábláról. 
		\subitem A {\tt filterForMove} eljárás azokat a pozíciókat hagyja a listában, amelyre a báb ütés nélkül léphet.
		\subitem A {\tt filterForTake} eljárás azokat a pozíciókat adja meg, amelyeken ütni lehetséges, vagyis amelyeken az ellenfél bábuja áll.
		\subitem A {\tt filterForMoveOrTake} a fenti két eljárás értelemszerű kombinációja.
	\item A {\tt moveOrTakeStraightFrom}, {\tt moveOrTakePlaneDiagonallyFrom} és {\tt moveOrTakeTrueDiagonallyFrom} függvények azon bábok mozgásának leírásához nyújtanak segítséget, amelyek egy adott pozícióból egy adott irányba tetszőleges számút léphetnek. A függvények az megadott pozícióból elindulva sorra megvizsgálják, hogy az adott irányokba haladva szabad-e az út a bábu előtt, illetve lehetséges-e az ellenfél egy bábuját kiütni. Mindhárom függvény az elérhető pozíciók listáját adja visszatérési értékként. A {\tt moveOrTakeStraightFrom} függvény a bástya mozgásának irányait vizsgálja, a tábla síkjaira merőleges irányokat. A {\tt moveOrTakePlaneDiagonallyFrom} függvény a tábla síkjaiban átlós mozgással elérhető mezőket eredményezi. A {\tt moveOrTakeTrueDiagonallyFrom} függvény az Unikornis mozgási lehetőségeit számolja ki. A Vezér mozgási lehetőségeit e három függvény eredményeinek uniója alkotja.
	
	Hogy e három függvényt megvalósítsa, a Piece osztály definiál még két segédeljárást.
	\subitem Az {\tt addPositionsFromSourceInDirection} eljárás egy adott pozícióból egy adott irányba elhelyezkedő pozíciókat adja hozzá egy már meglévő pozíciólistához. Az eljárás érdekessége, hogy az irány fogalmát egy Position objektumból Position objektumot létrehozó függvény (DirectionFunction) segítségével ragadja meg. Az elemi irányfüggvényeket a Position osztály már definiálta, ezekből összetett irányfüggvényeket pedig lambda-kifejezések segítségével definiálhatunk.
	\subitem Az {\tt addPositionsFromSourceInManyDirections} eljárás annyiban tér el az előzőtől, hogy nem egyetlen irányfüggvényt, hanem irányfüggvények listáját várja paraméterül. A listát feldolgozza, és az összes megadott irányba leellenőrzi, hogy meddig lehetséges a lépés.
\end{itemize}
A Piece osztály segédfüggvényeinek megvalósításánál igen hasznosnak bizonyultak a funkcionális programozás terén folytatott tanulmányaim.

A Piece osztály leszármazottjai a King, a Queen, a Knight, a Bishop, a Rook, az Unicorn és a Pawn osztályok. Többségük csak a {\tt getFigure} és {\tt getPossibleMoves} metódusokat definiálja felül.

\subsubsection{A Board osztály}

A Board osztály biztosítja a játéktábla belső reprezentációját. A táblát egy szótár (std::map) adatszerkezettel írja le, melyben a kulcsok Position objektumok, az értékek pedig Piece objektumokra mutató pointerek. Ez az adatszerkezet nagy hatékonysággal valósítja meg a pozíció alapú bábukeresést, amelyre a sakk- és mattvizsgálat során nagy számban van szükség.

A Board osztály lehetővé teszi, hogy hozzáadjuk egy bábut a táblához ({\tt addPiece} metódus), eltávolítsunk egy bábut a tábláról ({\tt removePiece} metódus), lekérjünk egy bábut egy adott pozícióról ({\tt getPiece} metódus), megállapítsuk egy pozícióról, hogy van-e rajta báb ({\tt isOccupied} metódus). Ezen felül lehetőségünk van egy adott játékos adott figuráját megkeresni a táblán ({\tt find} metódus, amely egy pozícióval tér vissza), illetve az adott játékos összes még játékban lévő bábuját is lekérhetjük ({\tt getAllPiecesFor} metódus). A {\tt getFullBoard} metódus segítségével pedig egy olyan reprezentációját kapjuk a táblának (Fullboard struktúra), amelyet a Nézet könnyen meg tud jeleníteni.

\subsubsection{A GameEvent osztály és leszármazottai}

A GameEvent osztály a játszma egy eseményét reprezentálja a Modellben. Ilyen események például a játszma kezdete, vagy egy lépés megtétele. A GameEvent osztály a Command programfejlesztési mintán alapul \cite{designpatterns}. Minden GameEvent objektum rendelkezik egy mutatóval, amely az aktuális játszmát reprezentáló Game osztály példányára mutat. Ezen mutatón keresztül a GameEvent objektumok különböző módosításokat tehetnek a játszma reprezentációján.

A GameEvent osztály három absztrakt metódust tartalmaz, ezek az {\tt execute}, a {\tt revert} és a {\tt getNotation}. Az {\tt execute} metódus segítségével a játszmaesemény (például lépés) végrehajtásra kerül. A {\tt revert} metódus megpróbálja visszaállítani az esemény előtti állapotot. E két metódus segítségével a játsz\-ma\-tör\-té\-net\-ben lépkedni lehet.

A GameEvent osztály felelős azért is, hogy az általa reprezentált játszmaeseményről információt adjon. Az említett {\tt getNotation} metódus visszaadja az esemény jelölését egy sztringben. A {\tt getPlayer} metódus megadja az esemény során cselekvő játékost (ez akár Nobody értékkel is bírhat, például a játszma elindítását reprezentáló esemény esetében). A {\tt getMoveNumber} megadja, hogy az esemény a játszmatörténetben hanyadik lépésnél következik be.

A GameEvent osztály {\tt generateMove} statikus metódusával generálhatunk Move objektumokat, melyek a GameEvent leszármazottjai. A metódus vagy két pozíciót (honnan és hova), vagy egy lépést leíró sztringet vár paraméterül, továbbá egy mutatót az aktuális játszmát leíró Game objektumra. A lépést leíró sztring formátuma a következő:
\begin{itemize}
	\item az első három karakter annak a pozíciónak a játékbeli jelölése, amelyről lépni szeretnénk,
	\item ezt egy szóköz követi,
	\item az utolsó három karakter pedgi annak a pozíciónak a leíró jelölése, ahova lépni akarunk.
\end{itemize}
Egy lehetséges lépést leíró sztring például az "Aa1 Bb2", vagy a "Cc3 Bc5".

\subsubsection{A History osztály}

A History osztály kezeli a játszmatörténetet. Belső reprezentációja egy GameEvent objektumokra mutató pointerekből álló vektor. A History osztály tartalmaz egy mutatót az őt attribútumként tartalmazó, a játszmát reprezentáló Game osztályra. Ezen mutatón keresztül tudja a játszma belső reprezentációját megváltoztatni. A History osztályt érdemes úgy elképzelni, mint egy GameEvent objektumokból álló listát. A History objektumnak van egy aktuális eleme, amely legutoljára végrehajtásra került. A History létrejöttekor automatikusan tartalmaz egy Creation objektumot, amely a GameEvent osztály leszármazottja, és a játszma kezdetét jelöli. A játszmatörténethez ezután az {\tt addEvent} metódussal adhatunk hozzá eseményeket. A {\tt reset} metódus a játszmatörténet elejére ugrik, az {\tt actualize} metódus pedig a végére, vagyis végrehajtja a listában található összes eseményt. A {\tt stepForward} és {\tt stepBack} metódusokkal lépdelhetünk előre illetve hátra a játszmatörténetben. A {\tt clearFuture} metódus törli az összes olyan eseményt, amely az aktuális esemény után szerepel még a listában.

A {\tt getCurrentEvent} metódussal lekérhetjük az utolsó végrehajtott eseményt. A {\tt getPlayerForLastEvent} és a {\tt getMoveNumberForLastEvent} az utolsó eseményben érintett játékost, illetve a lépés számát adja vissza. Ez utóbbi számozás a sakkban szokásos módon történik, vagyis nem az egyes lépések, hanem világos-sötét lépéspárok kerülnek számozásra. A {\tt getNextPlayer} metódus megadja az aktuálisan soron következő játékost.

Egy History objektum szövegfolyammá alakítható, illetve szövegfolyamból beolvasható a folyamokon felüldefiniált $<<$ és $>>$ operátorok segítségével.

\subsubsection{A Judge osztály}

A Judge osztály a játszma aktuális állásában legális lépések, valamint a sakk, patt és matt megállapítására szolgál. Ezen tevékenységekhez a Judge osztály igénybe veszi az aktuális játszmát reprezentáló Game osztálytól elkért Board és History objektumok szolgáltatásait. A Game osztály aktuális példányát a Judge osztály konstruktorparaméteren, egy mutatón keresztül kapja meg.

A Judge a következő publikus szolgáltatásokat nyújtja:

\begin{itemize}
	\item Az {\tt isValidMove} logikai függvény megmondja, hogy egy pozíció-pár által megadott lépés szabályos-e.
	
	\item Az {\tt isInCheck} logikai függvény megmondja, hogy a paraméterként kapott játékos királya sakkban van-e. Ehhez lekérdezi a Board objektumtól a király pozícióját, illetve a másik játékos összes bábuját egy listába. A bábuk listáján lineáris keresés segítségével olyan bábut keres, amelynek ütési lehetőségei között szerepel a király pozíciója. Mivel egy bábu lépési lehetőségeinek elméleti felső korlátját adja a 124 mező, és az ellenfélnek legfeljebb 20 bábuja lehet, a függvény műveletigénye O(1).
	
	\item a {\tt getCurrentlyPossibleMovesFrom} metódus egy pozíciót kap paraméterül,  és egy listában megadja, hogy a soron következő játékos az adott pozíción lévő bábuval mely helyekre léphet. Amennyiben az adott pozíción nincs a soron következő játékosnak bábuja, nullptr-t kapunk vissza. A Judge a lehetséges lépések meghatározásánál az adott figurák elhelyezkedésén és képességein túl figyelembe veszi azt a szabályt, hogy a király nem kerülhet sakkba a lépés következtében, valamint ha sakkban van, akkor csak az számít érvényes lépésnek, aminek következtében a sakk megszűnik.
	
	Utóbbi megállapításához a Judge osztály a {\tt filterTargetsForNotInCheckAfter} függvényt alkalmazza. Ez a függvény paraméterül megkapja a kiindulási pozíciót, valamint az összes elérhető pozíció listáját. Ebből a listából egy szótárt készít, amelyben a célpozíció adja a kulcsot, értékként pedig minden egyes célpozícióhoz legenerálja a lépést megvalósító GameEvent objektumot. Ezután a History objektumot hívja segítségül a lépés utáni helyzet vizsgálatához a következő algoritmussal: létrehoz egy új, üres listát a legális célpozícióknak, majd végigiterál a szótár összes elemén, és az adott Move játékeseményt hozzáadja a játszmatörténethez, majd végrehajtja azt. Az új helyzetben az {\tt isInCheck} függvény segítségével megvizsgálja, hogy a lépést követően sakkban van-e a király, és amennyiben nem, a lépés legális, a szótár kulcsát, azaz a célpozíciót hozzáveszi a szabályos célpozíciókat tartalmazó listához. A ciklus magja ezután a visszalép a játsz\-ma\-tör\-té\-net\-ben, és a hozzáadott Move eseményt törli a történet végéről. A ciklus végén a függvény visszatér a legális lépéseket tartalmazó listával. Mivel az {\tt isInCheck} függvény műveletigénye O(1), és a lehetséges célpozíciók számára elméleti felső korlát a 124, a {\tt filterTargetsForNotInCheckAfter} függvény műveletigénye szintén O(1) lesz. A valós műveletigény felső korlátját meghatározó konstans azonban az eddigi korlátokkal számolva $124 \times 20 \times 124 = 307520$!

	\item A {\tt canMove} metódus megadja, hogy a paraméterként kapott játékos tud-e egyáltalán legális lépést tenni. A metódus lekéri a Board objektumtól a játékos összes bábuját, majd a listán egy lineáris keresést hajt végre. A lineáris keresés során azt vizsgálja, hogy az adott bábu által legálisan megtehető lépések listájának van-e legalább egy eleme. A vizsgálat során nem a Piece objektum {\tt getPossibleMove} eljárására támaszkodik, hanem a Judge saját {\tt getPossibleMove} megvalósítására, amely tartalmazza a lépés utáni sakk-ellenőrzést is. Ez azt jelenti, hogy a függvény közvetve legfeljebb 20-szor hívja meg a {\tt filterTargetsForNotInCheckAfter} függvényt. A műveletigény így továbbra is O(1) marad, azonban a valós műveletigényre vonatkozó felső becslésünk eléri a $20 \times 310000 = 6200000$ műveletet. Itt már intuitívan érezhető, hogy a becslések során a becslés hibája "elszállt". A hiba az elméleti felső korlátok hibás alkalmazásában keresendő, például míg bábunként 124 lépési lehetőséget adtunk meg (a tábla korlátja), a kezdetben a bábuk felét adó gyalogok legfeljebb 7 mezőre léphetnek, a 4 bástya egyenként legfeljebb 12 mezőre, és a legtöbb lépési lehetőséggel rendelkező vezér legfeljebb (a tábla Cc3 mezőjén állva) 52 mezőre. Már akkor jelentősen javítunk a {\tt canMove} függvény műveletigényének becslésén, ha a vezér lépéseinek maximumával számolunk, ekkor a műveletigényre lehetséges felső korlát az $ 52 \times 20 \times 52 \times 20 = 1081600$.
\end{itemize}

\subsubsection{A Game osztály}

A Game osztály a Model legfelső szintű osztálya, és egy Térsakk játszma teljes számítógépes reprezentálását biztosítja. A Game osztály ehhez három fő osztálynak delegál feladatokat:
\begin{itemize}
	\item a Board osztály biztosítja a tábla és az azon elhelyezkedő bábuk belső reprezentációját,
	\item a History osztály biztosítja a játszmatörténetet, azaz a játszma lépéseinek rögzítését,
	\item a Judge osztály biztosítja a szabályok betartását.
\end{itemize}
Mivel ezek a funkciók kölcsönösen összefüggenek, mindhárom osztály közvetlen vagy közvetett módon kommunikál egymással.

A Game osztály megvalósítja az IGameInfo interfészt, amelyen keresztül a játszma állapotáról információ kérhető:
\begin{itemize}
	\item a {\tt getGameState} metódus a játszma aktuális állapotát adja eredményül, a megjelenítő általi közvetlen felhasználás céljára. Ez tartalmazza többek között a bábuk elhelyezkedését a táblán;
	\item a {\tt getCurrentlyPossibleMovesFrom} metódus megadja, hogy az aktuális játékos egy adott mezőről mely más mezőkre léphet;
	\item a {\tt getNextPlayer} metódus megadja a lépésre következő játékost;
	\item a {\tt getBoard}, {\tt getHistory}, {\tt getJudge} metódusok segítségével kérhetjük le az adott alegységet megvalósító objektomokat\footnote{Megjegyzés: mivel az IGameInfo interfész viszonylag későn került bevezetésre, jelenleg ezek a metódusai nem biztosítják az adott alegység konstansként való kezelését. Ennek biztosítása a továbbfejlesztés egyik első lépése kell legyen.}.
\end{itemize}

A Vezérlő osztályai a Game osztály {\tt move} metódusával kezdeményezhetnek lépéseket, illetve a {\tt stepForward, stepBackward} metódusokkal lehetőség van előre és hátra lépkedni a játszmatörténetben. A játszmák elmentését illetve betöltését a folyamokon felüldefiniált $<<$ és $>>$ operátorok biztosítják.

\subsubsection{A GameState, a Fullboard és a Field struktúrák}

\subsection{A megjelenítés}

\section{A tesztelés}


Érdekesebb részek...

\section{Továbbfejlesztési lehetőségek}

\begin{thebibliography}{Catch}
	\bibitem[Catch]{catch} Catch, github.com/philsquared/Catch, 2015.02.01
			
	\bibitem[CC]{cleancode} Robert C. Martin: Tiszta Kód, Kiskapu, 2010, [466], ISBN 978-963-9637-69-6

	\bibitem[CMake]{cmake} CMake, www.cmake.org, 2014.12.01.
	
	\bibitem[GoF]{designpatterns} Gamma, ... : Design Patterns, ...
	
	\bibitem[Raum]{chessvariants} Bruce Balden, Hans L. Bodlaender: Raumschach, The Chess Variant Pages, www.chessvariants.org/3d.dir/3d5.html, 2014.06.01.
		
	\bibitem[SFML]{sfml} Simple and Fast Multimedia Library, www.sfml-dev.org, 2014.12.01.
\end{thebibliography}

\end{document}          
