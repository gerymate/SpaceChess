% !TeX spellcheck = hu_HU
\documentclass[12pt, twoside]{report}
\usepackage[utf8]{inputenc}
\usepackage[magyar]{babel}
\usepackage[inner=3.5cm, outer=2.5cm, top=2.5cm, bottom=2.5cm]{geometry}
\usepackage{graphicx}
\linespread{1.5}



% Title Page
\title{Térsakk}
\author{Máté Gergely}


\begin{document}

% % %
\begin{titlepage}
	\thispagestyle{empty}
	
	\begin{minipage}{0.30\linewidth}
		\includegraphics[scale=0.4]{eltecimer.eps}
	\end{minipage}
	\begin{minipage}{0.50\linewidth}
		\begin{center}
			Eötvös Loránd Tudományegyetem \\
			Informatikai Kar\\
			Programozási Nyelvek és Fordítóprogramok Tanszék
		\end{center}
	\end{minipage}
	
	
	\vspace{7cm}
	
	\begin{center}
		\Huge
		\textbf{Térsakk}
		\normalsize
	\end{center}
	
	\vspace{5.4cm}
	
	
	\begin{minipage}{0.5\linewidth}
		\textbf{Pataki Norbert}\\
		Adjunktus
	\end{minipage}
	\begin{minipage}{0.5\linewidth}
		\textbf{Máté Gergely}\\
		Programtervező Informatikus BSc
	\end{minipage}
	
	\vspace{4cm}
	
	\begin{center}
		Budapest, 2015
	\end{center}
	
\end{titlepage}

% % %
\tableofcontents

\chapter{Bevezető}

A Térsakk olyan sakkvariáns, amelyben a játéktábla két dimenziója kiegészül egy harmadikkal. Jómagam gyerekkorom óta szeretek sakkozni, felnőttkoromra ez egyik kedvenc hobbimmá, szenvedélyemmé vált. A Térsakkban a bábuk kilépnek a síkból, és nagyon izgalmas térbeli mozgáslehetőségek, különleges kombinációk jelennek meg. 

Gyerekkorom másik szenvedélye a számítógépes játékok játszása volt, ebből eredően tizenéves korom óta magamban hordozom az igényt, hogy magam is készítsek számítógépes játékot. A Térsakk a tábla szerkezetéből adódóan igen nehezen játszható valódi sakk-készlettel; még ha ügyes barkácsember el is készítheti az emeletes sakktáblát, a lépések kivitelezése, szabályosságának biztosítása nehéz feladat. A számítógép erre a feladatra különösen alkalmas, ezért döntöttem úgy, hogy ezt a játékot valósítom meg szakdolgozati témám gyanánt.

Célomul azt tűztem ki, hogy elkészítem a Térsakk játék számítógépen játszható változatát. 

\section{A Térsakk rövid története}
A Térsakkot - eredeti nevén, németül: Raumschach - Dr. Ferdinand Maack találta fel 1907-ben  \cite{chessvariants}. Maack a nyugati világban addigra széles körben elterjedt hagyományos sakkjátékot szerette volna kiterjeszteni három dimenzióra. Eleinte $ 8 \times 8 \times 8 $ mezőből álló táblával kísérletezett, egy erre a célra kialakított polcon egymás fölé helyezett nyolc hagyományos sakktáblát. Ekkor azonban 512 mezőből áll a tábla, és mivel játékosonként csak 32 bábu van, a bábuk aránya a mezők számához viszonyítva mindössze 1:8 - szemben a hagyományos sakk 1:2 arányával. Mivel ez nagyon lassú játékhoz vezet, Maack később arra jutott, hogy az $ 5 \times 5 \times 5 $-ös táblaméret kellemesebb játékot eredményez. Ekkor játékosonként 20 bábu van a táblán, és a bábuk aránya a mezők számához viszonyítva 1:3.125-höz. A második világháborúig bezárólag még Raumschach-klub is működött Hamburgban, azonban ezután a játék - feltehetően a nehézkes fizikai megvalósítás miatt - feledésbe merült.

\section{A játék szabályai, menete}
A Térsakk a hagyományos sakk kiterjesztése térbeli táblára. Dolgozatomban a hagyományos sakk szabályait ismertnek tekintem, mivel ezen a téren rengeteg kiváló irodalom áll rendelkezésre. A játékmenet a hagyományos sakkéval megegyezik, világos kezd, világos és sötét felváltva lépnek, és a játék célja az ellenfél királyának bemattolása. Ezért a Térsakk szabályainak ismertetése kapcsán a hagyományos sakktól való eltérésekre koncentrálok.

\subsection{Tábla, jelölés}
A Térsakk egy $ 5 \times 5 \times 5 $ "mezőből" álló kockában játszódik. Ezt úgy is elképzelhetjük, mintha készítenénk öt darab $ 5 \times 5 $-ös sík sakktáblát, és egymás fölé helyeznénk azokat. A figurák egy adott mezőről nem csak az adott síkbeli mezőkre léphetnek, hanem például a mező fölötti, illetve alatti mezőkre is. A mezők jelölése hasonló a hagyományos sakkéhoz, azonban kiegészül a \textbf{szint} jelölésével: az egymás fölötti sakktáblákat lentről felfelé az A, B, C, D, E (nagy)betűkkel jelöljük. Az egyes szinteken belül a \textbf{vonal}at balról jobbra a, b, c, d, e (kis)betűk jelölik, a \textbf{sor}okat pedig a világos oldaltól távolodva az 1, 2, 3, 4, 5 számok. Így például kezdetben a világos bástyáit tartalmazó mezők az Aa1 és Ae1 mezők, míg sötét bástyái a kocka átellenes sarkaiban, az Ea5 és Ee5 mezőkön állnak.

\subsection{Kezdőállás}
A játékban mindkét játékosnak 20-20 báb áll a rendelkezésére. Ezek az \textit{unikornis} kivételével a hagyományos sakkból ismert bábok. Világos bábui az alsó két szinten (A, B), az első két soron (1, 2) helyezkednek el. A második soron csak gyalogok állnak. Az A szint első sorában áll balról jobbra egy bástya, egy huszár, a király, a másik huszár, a másik bástya. A B szint első sorában aszimmetrikusan helyezkednek el a bábok, hogy a futók különböző alapszínre (világos és sötét mezőre is) kerüljenek. Itt a világos mezőn álló futó, egy unikornis, a vezér, a sötét mezőn álló futó és még egy unikornis követik egymást.

Sötét bábjai a felső két szinten (D és E), az utolsó két soron (4, 5) kezdenek. A negyedik soron - mintegy védőfalként a tisztek előtt - csak gyalogok állnak. Az E szint ötödik során a világoséval megegyező sorrendben helyezkednek el a két sötét bástya, a két sötét huszár és a sötét király. A D szint ötödik során sötét bábjai szintén tükrözik a világoséit, vagyis balról jobbra a világos mezőn álló futó, egy unikornis, a vezér, a sötét mezőn álló futó, és még egy unikornis következik.

Némileg meglepő lehet - a játéktér térbeli felépítéséből és a kezdőállásból következik - hogy a vezérsor bábjai már a játék elején, gyaloglépés nélkül is képesek az ellenfél gyalogjait azonnal leütni.

\subsection{Bábuk, lépések}

\subsubsection{A király}

A király az összes körülötte lévő mezőre léphet. Ez nem csak az adott szinten lévő szomszédos (oldallal vagy sarokkal érintkező) mezőket jelenti, hanem az eggyel lejjebbi illetve feljebbi szinteken lévő szomszédos mezőket is. Ez a tábla belsejében szabadon álló király esetén 26 mezőt jelent (9 egy szinttel feljebb, 8 az adott szinten, 9 egy szinttel lejjebb). A hagyományos sakkhoz hasonlóan nem léphetünk úgy, hogy a királyunk sakkba kerüljön. Sáncolni nem lehetséges.

\subsubsection{A vezér}

A vezér a Térsakk legerősebb bábja. A hagyományos sakkhoz hasonlóan tetszőleges számú mezőt haladhat egy adott irányba. Ez az irány lehet egyenes (mint a bástya), vagy egy sík mentén átlós (mint a futó), vagy akár a kocka átlójával párhuzamosan átlós (mint az unikornis).

\subsubsection{A bástya}

A bástya a tábla adta koordináta-rendszer három tengelyével párhuzamos irányokba tetszőleges számú mezőt mehet előre. Ez a tábla belsejében szabadon álló bástya esetén hat irányt jelent, a hagyományos sakk irányai kiegészülnek a fel- illetve lefelé történő mozgással. Amennyiben egy mezőre kockaként tekintünk, a bástya mindig a kocka oldallapján halad keresztül.

\subsubsection{Az unikornis}

Az unikornis a kocka átlóival párhuzamos irányokba tetszőleges számú lépést tehet. Ez a tábla belsejében szabadon álló unikornis esetén nyolc irányt jelent. Amennyiben egy mezőre kockaként tekintünk, az unikornis mindig a kocka csúcsain halad át.

\subsubsection{A futó}

A futó a hagyományos sakkhoz hasonlóan, síkban átlósan mozog. Mivel egy mezőt három sík is tartalmaz (vízszintesen az egyes szintek, függőlegesen az egyes vonalak és az egyes sorok által meghatározott síkok), egy a tábla belsejében szabadon álló futó 12 irányba indulhat el. Amennyiben egy mezőre kockaként tekintünk, a futó azt a kocka összes élén keresztül hagyhatja el. 

\subsubsection{A huszár}

A huszár a hagyományos sakkhoz hasonlóan két lépést tesz egy adott irányba, majd egy lépést arra az irányra merőlegesen. Ez azonban a térbeli szerkezetből fakadóan hat kezdeti irányt, és a merőleges választásánál kezdeti irányonként négy további lehetőséget jelent. A huszár útja során a közben álló bábokat átugorja. 

\subsubsection{A gyalog}

A világos gyalogok a sötét alapvonalak felé, a sötét gyalogok a világos alapvonalak felé haladnak. Kezdeti kettős lépés a tábla kis mérete miatt nincs. Egy világos gyalog léphet előre (eggyel nagyobb számú sorba), vagy felfelé (egy szinttel feljebb). Ütni üthet az adott szinten átlósan előre, egy szinttel feljebb átlósan felfelé, valamint azonos vonalon maradva átlósan előre felfelé is. Sötét gyalogjai hasonlóan viselkednek, azonban világos alapsorai felé haladnak, vagyis adott szinten kisebb számú sorba, vagy pedig lefelé történhet a lépés. A gyalogok az ellenfél tisztjeinek alapsorait elérve vezérré változnak át.

\chapter{Felhasználói dokumentáció}

A Spacechess program segítségével Térsakkot lehet játszani a számítógépet használva tábla és bábuk helyett. A program lehetőséget ad rá, hogy két játékos ugyanazon számítógép előtt ülve megmérkőzzön egymással, továbbá arra is van lehetőség, hogy - TCP/IP hálózaton keresztül - két különböző számítógépről játsszanak egymás ellen. A program a befejeződött játszmákat elmenti, azok archiválhatóak és utólag visszanézhetőek. A szoftver platformfüggetlen, egyaránt futtatható GNU/Linux és Microsoft Windows operációs rendszerek alatt. A szoftver használatához grafikus környezetre és egérre (vagy más mutatóeszközre) van szükség.

\section{Telepítés}

A Spacechess program a "Spacechess" futtatható állományból, továbbá a bábok képét tartalmazó képfájlokból, illetve egy True Type Font betűtípus-leíró fájlból áll. Mindezeket egy közös mappába a számítógépre kell másolni. 

GNU/Linux operációs rendszer esetén a futtatáshoz szükséges, hogy a rendszerre az SFML multimédiás programkönyvtár minimálisan 2.1-es verziója telepítve legyen. Ubuntu rendszer esetén az SFML szükséges komponenseit a következő csomagok telepítésével biztosíthatjuk: libsfml-system2, libsfml-network2, libsfml-window2, libsfml-graphics2.

Microsoft Windows operációs rendszer esetén az SFML használatához szükséges DLL állományokat a Spacechess program mappájába kell elhelyezni (a mellékelt CD-n a mappa tartalmazza az állományokat). 

\section{Futtatás}	

Mivel a Spacechess program alapvetően GNU/Linux rendszerre lett fejlesztve, futtatása követi annak szemléletét, így a futtatás különböző módjait parancssori argumentumok megadásával lehet elérni. A programból minden üzemmódban a grafikus felület ablakának bezárásával léphetünk ki. A szoftver a következő módokon futtatható:
\subsection*{\tt Spacechess}
Argumentum megadása nélkül futtatva helyi játékot kezdünk, ahol mindkét játékos ugyanazon számítógép előtt ülve felváltva léphet.
\subsection*{\tt Spacechess -s [portszám]}
Az -s argumentum megadásával hálózati játékot kezdeményezhetünk, ilyenkor a program kiszolgáló üzemmódban indul el, és várja, hogy a szoftver egy másik példánya TCP/IP hálózaton keresztül csatlakozzon hozzá. Portszám megadása opcionális, alapértelmezésben az 54321 porton történik a csatlakozás.
\subsection*{\tt Spacechess -c [ipcím[:portszám]]}
A -c argumentum megadásával programunk csatlakozni próbál a szoftver egy másik példányához. Az "ipcím" paraméterrel adható meg a távoli számítógép hálózati címe (elhagyva a helyi számítógéphez próbál csatlakozni). A portszám megadása szintén opcionális, amennyiben nem az alapértelmezett hálózati porton szeretnék játszani, itt tudjuk az új portszámot megadni. Például a "{\tt Spacechess -c 192.168.0.2:4000}" parancs a 192.168.0.2 IP-címmel azonosított számítógép 4000-es számú portján keresi a kiszolgáló üzemmódban elindított Spacechess példányt, amit az adott számítógépen a "{\tt Spacechess -s 4000}" parancs segítségével indíthatunk el.
\subsection*{\tt Spacechess -r [fájlnév]}
Az -r argumentum segítségével visszajátszó üzemmódban indíthatjuk el a szoftvert. Alapértelmezésben a "lastspacechessgame.txt" állomány kerül megnyitásra, ez a fájlnév megadásával felülbírálható. A megadott állomány a Spacechess program által elmentett játszmaleíró fájl kell legyen.


\section{Játék egy számítógépen}

Amennyiben helyi játékot indítunk, megjelenik a grafikus felhasználói felület. A játékosok felváltva lépnek, világos kezd. 

\subsection{A játéktábla számítógépes megjelenítése}

A Spacechess program az $ 5 \times 5 \times 5 $ mezőből álló táblát 5 síktáblaként jeleníti meg. Azonban a síktáblák nem a kocka egyes szintjeit reprezentálják, hanem (balról jobbra haladva) a világos oldala felől nézve egymás után következő síkmetszeteket, vagyis a játéktábla sorait\footnote{A tábla térbeli szerkezetéből következik, hogy amit a hagyományos sakkban \textit{sor}nak nevezünk, az itt $ 5 \times 5 $ mezőt jelent: mind az 5 szinten egy-egy 5 mezőből álló sort.}. Így a képernyő bal oldalán megjelenő $ 5 \times 5 $ mezőből álló síktábla a világos színnel játszó játékoshoz legközelebb eső sorait tartalmazza a játéktáblának (a kocka legközelebbi szeletét). A képernyő jobb szélén található $ 5 \times 5 $ mezőből álló síktábla pedig a kocka legtávolabbi sorait, amelyen sötét tisztjei találhatóak az alapállásban. Így a képernyőn felfelé és lefelé mutató irány a térbeli sakktáblán is felfelé illetve lefelé mutat. 

A táblák fölött és mellett látható az eligazodást segítő jelölés ("ABCDE" a szintek, "abcde" a vonalak és "12345" a sorok jelölésére). Az egérmutatót az egyes mezők fölé mozgatva a tábla alatt megjelenik az adott mező jelölése (például Ac4 vagy Db3).

\subsection{A lépés}

Egérkattintás segítségével a soron következő játékos bábui kiválaszthatóak. Amennyiben a bábunak vannak lépési lehetőségei, ezek színezés segítségével megjelennek a táblán. Ha a játékos meggondolja magát, és inkább másik bábuval szeretne lépni, a korábban kiválasztott bábura ismét kattintva a kijelölés megszűnik, és ezután új báb választható. Amikor kijelöltünk egy bábut lépésre, majd egy átszínezett mezőre kattintunk, ahova a kijelölt bábu a játék szabályai szerint léphet, a lépés megtörténik, és ezután a másik játékos következik.

Nem lehet olyat lépni, aminek a következtében a királyunk sakkba kerülne, és ha a királyunk sakkban van, akkor lépésünkkel meg kell szüntessük a sakkot. Ha ez nem lehetséges, mattot kaptunk, ezt a program kijelzi. Amennyiben a királyunk nincsen sakkban, de semmilyen szabályos lépést nem tudunk tenni, ez patt, vagyis döntetlen, a program ezt is kijelzi\footnote{A hagyományos sakkban a patton kívül más módokon is létrejöhet döntetlen, például amennyiben ugyanaz az állás egymást követően háromszor létrejön a táblán, a bírótól döntetlen kérhető. Az ilyen döntetlenek lehetőségeivel a program nem foglalkozik.}.

Amennyiben egy gyalogunkkal belépünk az ellenfél tisztjeinek bázisára, gyalogunk automatikusan vezérré alakul át.

\section{Visszajátszás}

Bármikor, amikor egy játszma során bezárjuk az alkalmazást, az összes addigi lépés elmentésre kerül a "lastspacechessgame.txt" elnevezésű állományba. Ezt az állományt archiválási céllal átnevezhetjük, illetve az "-r" argumentummal indítva a programot a játszmát visszanézhetjük. A visszajátszás során megjelenik a grafikus felhasználói felület, a táblán a kezdőállással. A jobb oldali egérgombbal bárhol kattintva a játszma történetében egy lépést haladhatunk előre, vagyis megnézhetjük a következő lépés eredményét. A bal oldali egérgombbal kattintva az egy lépéssel korábbi állapotot kapjuk. Így oda-vissza végignézhetjük a játszma lépéseit.

\section{Játék hálózaton}

A hálózati játék során két, egymással TCP/IP hálózati kapcsolatban álló számítógépen két külön Spacechess program kommunikál. Ennek menete a következő:

Először elindítjuk a kiszolgálót az "-s" parancssori argumentummal. Megjelenik a grafikus felhasználói felület, és a program jelzi, hogy csatlakozásra vár.

Ekkor a másik játékos elindítja a csatlakozó szoftvert a "-c" argumentummal. Ha a csatlakozás sikeres, a játszma elindul. A csatlakozó játékos játszik világossal, így övé az első lépés. Amikor ezt megtette, a lépés megjelenik mindkét játékos számítógépén, és most sötéten a lépés sora. A lépés megtételének módja megegyezik a helyi játszmánál használható módozattal: a léptetni kívánt bábot kijelöljük, majd a célmezőre kattintunk, stb.

\chapter{Fejlesztői dokumentáció}

A Fejlesztői dokumentáció tartalmazza 
\begin{itemize}
\item a probléma részletes specifikációját, 
\item a felhasznált módszerek részletes leírását, a használt fogalmak definícióját,
\item a program logikai és fizikai szerkezetének leírását (adatszerkezetek, adatbázisok, modulfelbontás),
\item a tesztelési tervet és a tesztelés eredményeit.
\end{itemize}


\section{A szoftver informális specifikációja}

A szoftver célja, hogy a Térsakk játékot szimulálja, a Térsakk tábláját és bábuit virtuálisan megjelenítse, és segítségével két személy helyben egy számítógépen, vagy hálózaton keresztül két számítógépen Térsakk játszmákat játszhasson le. Célja továbbá, hogy a játszott játszmák archiválásra kerüljenek, és a szoftver segítségével visszanézhetőek legyenek.

Ezek a tevékenységek a felhasználó szemszögéből a következő UML diagramokkal írhatók le.

[ Felhasználói esetek diagramokkal ]

\section{A használt fejlesztői eszközök és módszerek}

\subsection{C++11}

A szoftver fejlesztése során elsődleges szempont volt, hogy a programot a lehető legtöbb számítógépen futtatni lehessen, vagyis a lehető legnagyobb mértékű platformfüggetlenség. Szempont volt továbbá a hatékonyság, hogy (jövőbeli fejlesztési lehetőségként) adott esetben kis számítási kapacitással rendelkező eszközökön (például mobiltelefonokon) is jól működjön a program. Ezért az implementáláshoz a C++ programozási nyelv 2011-es ISO szabványára (a továbbiakban C++11) esett a választás, mivel ez mind a széles körben elérhetőség, mind a hatékonyság követelményeinek megfelel. A program készítése során igyekeztem elsődlegesen a C++11 eszközeit használni, vagyis ha egy feladat megoldható a C++11 segítségével, akkor nem használtam harmadik fél által kínált programkönyvtárakat.

Ahogy haladtam a program fejlesztésével, a C++11 szabványnak egyre több szolgáltatását ismertem meg. A fejlesztés során igyekeztem folyamatosan hasznosítani az új ismereteket. Például míg eleinte konstruktorok segítségével inicializáltam a különböző objektumokat, később átálltam az egységes inicializáló-listák használatára. Vagy míg eleinte a \emph{new} kulcsszó segítségével inicializáltam a smart-pointereket, később átálltam a \emph{std::make\_shared\textless\textgreater()} sablonfüggvény használatára. Ennek köszönhetően azonban a C++ nyelv használata nem lett egységes a forrásszövegben, még a folyamatos refaktorálás ellenére sem.

\subsection{SFML}

Szintén a hatékonyság és a platformfüggetlenség kívánalmának akarván megfelelni, a grafikus felhasználói felület megvalósításához az OpenGl szabványra esett a választásom. Mivel azonban az OpenGl igényel valamilyen köztes réteget az alkalmazás és az operációs rendszer között (például önmagában nem tartalmaz ablakkezelést), a Simple Fast Muldimedia Library (továbbiakban SFML) nyílt forráskódú programkönyvtár segítségéhez fordultam. Mint kiderült, az SFML erősen objektumorientált szemléletű, és azon túl, hogy lehetőséget ad OpenGl programok írására, önmagában is rendelkezik magasabb szintű grafikus képességekkel, amelyek a program elkészítéséhez elégnek bizonyultak. Így aztán az OpenGl közvetlen programozására az alkalmazásban nem is került sor. 

Az SFML azon túl, hogy biztosítja az ablakkezelést és egyszerű grafikus műveleteket, az egér kezelését is egyszerűvé teszi, továbbá tartalmaz egy hálózati modult, amivel az operációs rendszer hálózati szolgáltatásait elfedi. Így az operációs rendszer szolgáltatásait a fájlkezelést illetően a C++11 szabvány könyvtára, az összes többi szolgáltatást illetően pedig az SFML elfedi. Az SFML mind GNU/Linux, mind Microsoft Windows, mind Apple OS-X környezetben működik, így használatával a platformfüggetlenség nagy mértékben megvalósult, a Spacechess program forráskódja lényegében változtatások nélkül\footnote{Apróbb változtatásokra szükség lehet, mivel a különböző fordítóprogramok a C++11 szabványt különböző mértékben valósítják meg.} lefordítható az említett platformokon. 

\subsection{CMake}

Mivel a Spacechess program nagyszámú forrásfájlból áll, szükségem volt egy egységes, több platformon is működő \emph{build}-rendszerre, amely a forrásfájlokból a megfelelő bináris állományokat elkészíti. Erre a célra a nyílt forrású CMake rendszert használtam. A CMake egy úgynevezett meta-build rendszer. A forráskód mappáiban elhelyezett {\tt CMakeList.txt} állományok a CMake saját programnyelvén\footnote{A CMake programnyelve leginkább a shell scriptek nyelveihez hasonló.} leírják, hogy a forrásfájlokat hogyan kell lefordítani. A CMake program ez alapján készíti el az adott platform és fejlesztőkörnyezet egyedi build állományait, például GNU/Linux esetén \emph{Makefile} állományokat, vagy Microsoft Visual Studio esetén a fordítás szerkezetét leíró \emph{Solution}-t. Ezután az adott fejlesztőeszköz végzi el a fordítást.

A Spacechess program kapcsán a CMake elemi használatához elég azt tudni, hogy amennyiben új C++ forrásállományt ({\tt *.cpp}) hozunk létre, annak nevét a tartalmazó mappa {\tt CMakeList.txt} állmányában a \emph{SOURCES} változó értékeként fel kell sorolni a fordításhoz.

\subsection{Catch}

A szoftver fejlesztése során célszerűnek tűnt az egyes részek működését automatikus teszteléssel biztosítani. Ehhez szükségem volt egy könnyek kezelhető tesztelési keretrendszerre. Némi tájékozódás után a Catch nevű eszközre esett a választás. A Catch egyetlen \emph{header} állományból áll, aminek következtében nagyon hamar üzembe tudtam állítani. A tesztfájlok a forráskód Tests almappájába kerültek, és első utasításként behívják a catch.hpp állományt. A tesztek lefordításához a forráskódhoz hasonlóan a CMake rendszer használatos. A fordítás során egy Tests nevű futtatható állomány keletkezik, amelyet végrehajtva az összes tesztünk ellenőrzésre kerül.

A tesztek forráskódja szabvány C++ szöveg néhány makróval kiegészítve. A SCENARIO makró segítségével teszteseteket adhatunk meg. A teszteseteken belül megadhatunk környezeteket a GIVEN, WHEN és THEN makrókkal, melyek azonos funkcionalitással bírnak, és tetszőleges mélységben egymásba ágyazhatóak. Az alacsonyabb szinten lévő környezetben történő változások egyáltalán nincsenek kihatással a magasabb szinten lévő környezetre, így azonos környezetet biztosíthatunk több különböző, egymás után végrehajtandó teszt számára, ha az előkészítést magasabb szinten, az egyes tesztesetek vizsgálatát alacsonyabb szinten végezzük el. Megadhatunk továbbá a programra vonatkozó logikai állításokat a REQUIRE makró paramétereként, ezek igaz volta kerül ellenőrzésre a teszt futtatása során.

A SCENARIO, GIVEN, THEN, WHEN makrók célja a Catch rendszerben a tesztvezérelt fejlesztés lehetővé tétele. Amennyiben erre nincs szükség, a Catch használata még egyszerűbb lehet. A SCENARIO makró helyett használható az azonos funkcionalitású TEST\_CASE makró, és a GIVEN, THEN, WHEN makrók helyettesíthetőek a SECTION makróval, amely tetszőleges mélységben tartalmazhat további SECTION makrókat. További tesztek készítéséhez ezt az egyszerűbb megközelítést javaslom.

\subsection{További felhasznált eszközök}

A fejlesztést elsődlegesen Ubuntu GNU/Linux rendszeren végeztem. Fejlesztői környezetnek a nagyszerű KDevelop integrált fejlesztőrendszert használtam. A sakkbábuk képfájljait az Inkscape program segítségével szabtam a program igényeihez. Az eredeti képfájlokat Uray Marcell János készítette és tette szabadon felhasználhatóvá. A programban használt betűtípus szintén szabadon felhasználható, és az SFML példaállományaiból származik. A Microsoft Windows alatt működő változat a Visual Studio Community 2013 verziójával került lefordításra.

\subsection{Módszertan}

A program fejlesztése során több fejlesztési és projekt-kivitelezési módszertant is kipróbáltam. Folyamatosan törekedtem az objektum-orientált fejlesztési elvek minél teljesebb elsajátítására. A fejlesztés iteratív folyamat volt, amelyben tervezési szakaszokat kódolási szakaszok váltottak. A tervezést többnyire UML diagramok készítése jelentette. A kódolási szakaszban a diagramok alapján készítettem kódot, azonban az eközben felmerülő problémákra már kódban kerestem megoldást. Amikor kezdtem elveszteni a tájékozódást a kódban, az alapján frissítettem az UML diagramokat, és ismét az UML szintjén végeztem a tervezést. Körülbelül nyolc ilyen tervezés-kódolás iterációt csináltam végig.

A projekt menedzselése során egy agilisnek tekinthető módszert, a SMART módszertant követtem. Ennek keretében két-három hetes időszakokra egyszerűbb, jól körülhatárolt, reálisan megvalósítandó célokat tűztünk ki a konzulensem segítségével, melyeket írásban rögzítettem. Bár a határidőket időnként nem sikerült tartanom, a módszer tervezhetősége folytán lehetőséget adott a korrekciókra.

Az agilis fejlesztési módszerek alkalmazásában nagyon nagy hatással volt rám Robert C. Martin Tiszta Kód című könyve \cite{cleancode}. Ennek eredményeképpen jelentek meg a kódban nagy számban a különböző részfeladatokat ellátó privát eljárások. Ennek köszönhető, hogy a kódban nagyon kevés megjegyzés maradt, helyettük a függvények és változók hosszú, beszédes neveket kaptak annak érdekében, hogy szerepük és funkciójuk megjegyzések nélkül is tisztán és világosan érthetővé váljon a kód olvasója számára. A programot folyamatosan refaktoráltam, hogy minél egyszerűbbé, minél érthetőbbé váljon a forráskód.

\section{A program logikai szerkezete}

A Spacechess program megvalósításához a Modell-Nézet-Vezérlő architektúrát választottam. A három modul kezdetben nagyon elvált egymástól, a Nézet csak a Vezérlőn keresztül kommunikált a Modellel. Ez nehézkesnek bizonyult, ezért létrehoztam a Modell számára egy csak olvasható interfészt, és a Nézet immár ezen keresztül közvetlenül is lekérheti a Modell állapotának részleteit. A három modul három különböző névtérben helyezkedik el.

\subsection{A vezérlés}

A {\tt main} függvény és az alkalmazás osztály kivételével az összes vezérlési osztály a \mbox{Controller} névtérben kapott helyet.

\subsubsection{A program belépési pontja}

A program belépési pontja a {\tt main} függvény, ami mindösszesen létrehoz egy alkalmazás (App) objektumot, és delegálja a parancssori paramétereket számára.

\subsubsection{Az App osztály}

Az App osztály létrehozza a grafikus felhasználói felület ablakát ({\tt setUpWindow} metódus), és a parancssori paraméterek függvényében a megfelelő vezérlő objektumot ({\tt setUpAGameController} metódus). Amennyiben a parancssori paraméterek nem megfelelőek, erről tájékoztatást ad ({\tt showUsage} metódus), majd a program kilép.

\subsubsection{A GameController osztály és leszármazottai}

A GameController osztály leszármazottai biztosítják a program különféle működési módjainak vezérlését. A LocalGameController a helyi játék lebonyolításáért felelős, a NetworkGameController a hálózati játék működtetéséért. A PlaybackController osztály szintén a GameController leszármazottja, a játszmák visszajátszásának vezérlését valósítja meg.

A GameController osztály öröklődő attribútuma a Modell játszma (Game) osztályának egy példánya, továbbá a Nézet grafikus megjelenítésért felelős Render2D osztályának egy példánya. A vezérlő és a nézet közötti belső üzenetküldésre használatos az EventQueue osztály egy példánya által megvalósított, belső eseményeket leíró üzenetsor. 

A GameController osztály három absztrakt metódust tartalmaz. Ezek a {\tt mainLoop}, amelyben a vezérlési ciklust kell megvalósítani, a {\tt handleSystemEvents}, amely az SFML által közvetített rendszeresemények lekezelését szolgálja, és a {\tt handleGameEvents}, amelyben a belső üzenetsor (EventQueue) eseményeit kezeljük le. Az App osztály a GameController valamely leszármazottjának {\tt mainLoop} metódusának adja át a vezérlést.



\subsection {A játékmodell}

\subsection{A megjelenítés}

\section{A tesztelés}


Érdekesebb részek...

\section{Továbbfejlesztési lehetőségek}

\begin{thebibliography}{Raum}
	\bibitem[Raum]{chessvariants} Bruce Balden, Hans L. Bodlaender: Raumschach, The Chess Variant Pages, www.chessvariants.org/3d.dir/3d5.html, 2014 június 1.
			
	\bibitem[CC]{cleancode} Robert C. Martin: Tiszta Kód, Kiskapu, 2010, [466], ISBN 978-963-9637-69-6
\end{thebibliography}

\end{document}          
