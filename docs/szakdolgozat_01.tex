% !TeX spellcheck = hu_HU
\documentclass[12pt, twoside]{report}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[magyar]{babel}
\usepackage[inner=3.5cm, outer=2.5cm, top=2.5cm, bottom=2.5cm]{geometry}
\usepackage{graphicx}
\linespread{1.5}

\hyphenation{Spacechess Position Player Figure Game History Judge Board Piece GameEvent King Queen Knight Bishop Unicorn Pawn Rook EventQueue Event GameController Controller Model View BoardPainter PanelPainter Widget Makefile SCENARIO GIVEN WHEN THEN SECTION}

% Title Page
\title{Térsakk}
\author{Máté Gergely}


\begin{document}

% % %
\begin{titlepage}
	\thispagestyle{empty}
	
	\begin{minipage}{0.30\linewidth}
		\includegraphics[scale=0.4]{eltecimer.eps}
	\end{minipage}
	\begin{minipage}{0.50\linewidth}
		\begin{center}
			Eötvös Loránd Tudományegyetem \\
			Informatikai Kar\\
			Programozási Nyelvek és Fordítóprogramok Tanszék
		\end{center}
	\end{minipage}
	
	
	\vspace{7cm}
	
	\begin{center}
		\Huge
		\textbf{Térsakk}
		\normalsize
	\end{center}
	
	\vspace{5.4cm}
	
	
	\begin{minipage}{0.5\linewidth}
		\textbf{Pataki Norbert}\\
		Adjunktus
	\end{minipage}
	\begin{minipage}{0.5\linewidth}
		\textbf{Máté Gergely}\\
		Programtervező Informatikus BSc
	\end{minipage}
	
	\vspace{4cm}
	
	\begin{center}
		Budapest, 2015
	\end{center}
	
\end{titlepage}

% % %
\tableofcontents

\chapter{Bevezető}

A Térsakk olyan sakkvariáns, amelyben a játéktábla két dimenziója kiegészül egy harmadikkal. Jómagam gyerekkorom óta szeretek sakkozni, felnőttkoromra ez egyik kedvenc hobbimmá, szenvedélyemmé vált. A Térsakkban a bábuk kilépnek a síkból, és nagyon izgalmas térbeli mozgáslehetőségek, különleges kombinációk jelennek meg. 

Gyerekkorom másik szenvedélye a számítógépes játékok játszása volt, ebből eredően tizenéves korom óta magamban hordozom az igényt, hogy magam is készítsek szá\-mí\-tó\-gé\-pes játékot. A Térsakk a tábla szerkezetéből adódóan igen nehezen játszható valódi sakk-készlettel; még ha ügyes barkácsember el is készítheti az emeletes sakktáblát, a lépések kivitelezése, szabályosságának biztosítása nehéz feladat. A számítógép erre a feladatra különösen alkalmas, ezért döntöttem úgy, hogy ezt a játékot valósítom meg szakdolgozati témám gyanánt.

Célomul azt tűztem ki, hogy elkészítem a Térsakk játék számítógépen játszható változatát. 

\section{A Térsakk rövid története}
A Térsakkot - eredeti nevén, németül: Raumschach - Dr. Ferdinand Maack találta fel 1907-ben  \cite{chessvariants}. Maack a nyugati világban addigra széles körben elterjedt hagyományos sakkjátékot szerette volna kiterjeszteni három dimenzióra. Eleinte $ 8 \times 8 \times 8 $ mezőből álló táblával kísérletezett, egy erre a célra kialakított polcon egymás fölé helyezett nyolc hagyományos sakktáblát. Ekkor azonban 512 mezőből áll a tábla, és mivel játékosonként csak 32 bábu van, a bábuk aránya a mezők számához viszonyítva mindössze 1:8 - szemben a hagyományos sakk 1:2 arányával. Mivel ez nagyon lassú játékhoz vezet, Maack később arra jutott, hogy az $ 5 \times 5 \times 5 $-ös táblaméret kellemesebb játékot eredményez. Ekkor játékosonként 20 bábu van a táblán, és a bábuk aránya a mezők számához viszonyítva 1:3.125-höz. A második világháborúig bezárólag még Raumschach-klub is működött Hamburgban, azonban ezután a játék - feltehetően a nehézkes fizikai megvalósítás miatt - feledésbe merült.

\section{A játék szabályai, menete}
A Térsakk a hagyományos sakk kiterjesztése térbeli táblára. Dolgozatomban a hagyományos sakk szabályait ismertnek tekintem, mivel ezen a téren rengeteg kiváló irodalom áll rendelkezésre. A játékmenet a hagyományos sakkéval megegyezik, világos kezd, világos és sötét felváltva lépnek, és a játék célja az ellenfél királyának bemattolása. Ezért a Térsakk szabályainak ismertetése kapcsán a hagyományos sakktól való eltérésekre koncentrálok.

\subsection{Tábla, jelölés}
A Térsakk egy $ 5 \times 5 \times 5 $ "mezőből" álló kockában játszódik. Ezt úgy is elképzelhetjük, mintha készítenénk öt darab $ 5 \times 5 $-ös sík sakktáblát, és egymás fölé helyeznénk azokat. A figurák egy adott mezőről nem csak az adott síkbeli mezőkre léphetnek, hanem például a mező fölötti, illetve alatti mezőkre is. A mezők jelölése hasonló a hagyományos sakkéhoz, azonban kiegészül a \textbf{szint} jelölésével: az egymás fölötti sakktáblákat lentről felfelé az A, B, C, D, E (nagy)betűkkel jelöljük. Az egyes szinteken belül a \textbf{vonal}at balról jobbra a, b, c, d, e (kis)betűk jelölik, a \textbf{sor}okat pedig a világos oldaltól távolodva az 1, 2, 3, 4, 5 számok. Így például kezdetben a világos bástyáit tartalmazó mezők az Aa1 és Ae1 mezők, míg sötét bástyái a kocka átellenes sarkaiban, az Ea5 és Ee5 mezőkön állnak.

\subsection{Kezdőállás}
A játékban mindkét játékosnak 20-20 báb áll a rendelkezésére. Ezek az \textit{unikornis} kivételével a hagyományos sakkból ismert bábok. Világos bábui az alsó két szinten (A, B), az első két soron (1, 2) helyezkednek el. A második soron csak gyalogok állnak. Az A szint első sorában áll balról jobbra egy bástya, egy huszár, a király, a másik huszár, a másik bástya. A B szint első sorában aszimmetrikusan helyezkednek el a bábok, hogy a futók különböző alapszínre (világos és sötét mezőre is) kerüljenek. Itt a világos mezőn álló futó, egy unikornis, a vezér, a sötét mezőn álló futó és még egy unikornis követik egymást.

Sötét bábjai a felső két szinten (D és E), az utolsó két soron (4, 5) kezdenek. A negyedik soron - mintegy védőfalként a tisztek előtt - csak gyalogok állnak. Az E szint ötödik során a világoséval megegyező sorrendben helyezkednek el a két sötét bástya, a két sötét huszár és a sötét király. A D szint ötödik során sötét bábjai szintén tükrözik a világoséit, vagyis balról jobbra a világos mezőn álló futó, egy unikornis, a vezér, a sötét mezőn álló futó, és még egy unikornis következik.

Némileg meglepő lehet - a játéktér térbeli felépítéséből és a kezdőállásból következik - hogy a vezérsor bábjai már a játék elején, gyaloglépés nélkül is képesek az ellenfél gyalogjait azonnal leütni.

\subsection{Bábuk, lépések}

\subsubsection{A király}

A király az összes körülötte lévő mezőre léphet. Ez nem csak az adott szinten lévő szomszédos (oldallal vagy sarokkal érintkező) mezőket jelenti, hanem az eggyel lejjebbi illetve feljebbi szinteken lévő szomszédos mezőket is. Ez a tábla belsejében szabadon álló király esetén 26 mezőt jelent (9 egy szinttel feljebb, 8 az adott szinten, 9 egy szinttel lejjebb). A hagyományos sakkhoz hasonlóan nem léphetünk úgy, hogy a királyunk sakkba kerüljön. Sáncolni nem lehetséges.

\subsubsection{A vezér}

A vezér a Térsakk legerősebb bábja. A hagyományos sakkhoz hasonlóan tetszőleges számú mezőt haladhat egy adott irányba. Ez az irány lehet egyenes (mint a bástya), vagy egy sík mentén átlós (mint a futó), vagy akár a kocka átlójával párhuzamosan átlós (mint az unikornis).

\subsubsection{A bástya}

A bástya a tábla adta koordináta-rendszer három tengelyével párhuzamos irányokba tetszőleges számú mezőt mehet előre. Ez a tábla belsejében szabadon álló bástya esetén hat irányt jelent, a hagyományos sakk irányai kiegészülnek a fel- illetve lefelé történő mozgással. Amennyiben egy mezőre kockaként tekintünk, a bástya mindig a kocka oldallapján halad keresztül.

\subsubsection{Az unikornis}

Az unikornis a kocka átlóival párhuzamos irányokba tetszőleges számú lépést tehet. Ez a tábla belsejében szabadon álló unikornis esetén nyolc irányt jelent. Amennyiben egy mezőre kockaként tekintünk, az unikornis mindig a kocka csúcsain halad át.

\subsubsection{A futó}

A futó a hagyományos sakkhoz hasonlóan, síkban átlósan mozog. Mivel egy mezőt három sík is tartalmaz (vízszintesen az egyes szintek, függőlegesen az egyes vonalak és az egyes sorok által meghatározott síkok), egy a tábla belsejében szabadon álló futó 12 irányba indulhat el. Amennyiben egy mezőre kockaként tekintünk, a futó azt a kocka összes élén keresztül hagyhatja el. 

\subsubsection{A huszár}

A huszár a hagyományos sakkhoz hasonlóan két lépést tesz egy adott irányba, majd egy lépést arra az irányra merőlegesen. Ez azonban a térbeli szerkezetből fakadóan hat kezdeti irányt, és a merőleges választásánál kezdeti irányonként négy további lehetőséget jelent. A huszár útja során a közben álló bábokat átugorja. 

\subsubsection{A gyalog}

A világos gyalogok a sötét alapvonalak felé, a sötét gyalogok a világos alapvonalak felé haladnak. Kezdeti kettős lépés a tábla kis mérete miatt nincs. Egy világos gyalog léphet előre (eggyel nagyobb számú sorba), vagy felfelé (egy szinttel feljebb). Ütni üthet az adott szinten átlósan előre, egy szinttel feljebb átlósan felfelé, valamint azonos vonalon maradva átlósan előre felfelé is. Sötét gyalogjai hasonlóan viselkednek, azonban világos alapsorai felé haladnak, vagyis adott szinten kisebb számú sorba, vagy pedig lefelé történhet a lépés. A gyalogok az ellenfél tisztjeinek alapsorait elérve vezérré változnak át.

\chapter{Felhasználói dokumentáció}

A Spacechess program segítségével Térsakkot lehet játszani a számítógépet használva tábla és bábuk helyett. A program lehetőséget ad rá, hogy két játékos ugyanazon számítógép előtt ülve megmérkőzzön egymással, továbbá arra is van lehetőség, hogy - TCP/IP hálózaton keresztül - két különböző számítógépről játsszanak egymás ellen. A program a befejeződött játszmákat elmenti, azok archiválhatóak és utólag visszanézhetőek. A szoftver platformfüggetlen, egyaránt futtatható GNU/Linux és Microsoft Windows operációs rendszerek alatt. A szoftver használatához grafikus környezetre és egérre (vagy más mutatóeszközre) van szükség.

\section{Telepítés}

A Spacechess program a "Spacechess" futtatható állományból, továbbá a bábok képét tartalmazó képfájlokból, illetve egy True Type Font betűtípus-leíró fájlból áll. Mindezeket egy közös mappába a számítógépre kell másolni. 

GNU/Linux operációs rendszer esetén a futtatáshoz szükséges, hogy a rendszerre az SFML multimédiás programkönyvtár minimálisan 2.1-es verziója telepítve legyen. Ubuntu rendszer esetén az SFML szükséges komponenseit a következő csomagok telepítésével biztosíthatjuk: libsfml-system2, libsfml-network2, libsfml-window2, libsfml-graphics2.

Microsoft Windows operációs rendszer esetén az SFML használatához szükséges DLL állományokat a Spacechess program mappájába kell elhelyezni (a mellékelt CD-n a mappa tartalmazza az állományokat). 

\section{Futtatás}	

Mivel a Spacechess program alapvetően GNU/Linux rendszerre lett fejlesztve, futtatása követi annak szemléletét, így a futtatás különböző módjait parancssori argumentumok megadásával lehet elérni. A programból minden üzemmódban a grafikus felület ablakának bezárásával léphetünk ki. A szoftver a következő módokon futtatható:
\subsection*{\tt Spacechess}
Argumentum megadása nélkül futtatva helyi játékot kezdünk, ahol mindkét játékos ugyanazon számítógép előtt ülve felváltva léphet.
\subsection*{\tt Spacechess -s [portszám]}
Az -s argumentum megadásával hálózati játékot kezdeményezhetünk, ilyenkor a program kiszolgáló üzemmódban indul el, és várja, hogy a szoftver egy másik példánya TCP/IP hálózaton keresztül csatlakozzon hozzá. Portszám megadása opcionális, a\-lap\-ér\-tel\-me\-zés\-ben az 54321 porton történik a csatlakozás.
\subsection*{\tt Spacechess -c [ipcím[:portszám]]}
A -c argumentum megadásával programunk csatlakozni próbál a szoftver egy másik példányához. Az "ipcím" paraméterrel adható meg a távoli számítógép hálózati címe (elhagyva a helyi számítógéphez próbál csatlakozni). A portszám megadása szintén opcionális, amennyiben nem az alapértelmezett hálózati porton szeretnék játszani, itt tudjuk az új portszámot megadni. Például a "{\tt Spacechess -c 192.168.0.2:4000}" parancs a 192.168.0.2 IP-címmel azonosított számítógép 4000-es számú portján keresi a kiszolgáló üzemmódban elindított Spacechess példányt, amit az adott számítógépen a "{\tt Spacechess -s 4000}" parancs segítségével indíthatunk el.
\subsection*{\tt Spacechess -r [fájlnév]}
Az -r argumentum segítségével visszajátszó üzemmódban indíthatjuk el a szoftvert. Alapértelmezésben a "lastspacechessgame.txt" állomány kerül megnyitásra, ez a fájlnév megadásával felülbírálható. A megadott állomány a Spacechess program által elmentett játszmaleíró fájl kell legyen.


\section{Játék egy számítógépen}

Amennyiben helyi játékot indítunk, megjelenik a grafikus felhasználói felület. A já\-té\-ko\-sok felváltva lépnek, világos kezd. 

\subsection{A játéktábla számítógépes megjelenítése}

A Spacechess program az $ 5 \times 5 \times 5 $ mezőből álló táblát 5 síktáblaként jeleníti meg. Azonban a síktáblák nem a kocka egyes szintjeit reprezentálják, hanem (balról jobbra haladva) a világos oldala felől nézve egymás után következő síkmetszeteket, vagyis a játéktábla sorait\footnote{A tábla térbeli szerkezetéből következik, hogy amit a hagyományos sakkban \textit{sor}nak nevezünk, az itt $ 5 \times 5 $ mezőt jelent: mind az 5 szinten egy-egy 5 mezőből álló sort.}. Így a képernyő bal oldalán megjelenő $ 5 \times 5 $ mezőből álló síktábla a világos színnel játszó játékoshoz legközelebb eső sorait tartalmazza a játéktáblának (a kocka legközelebbi szeletét). A képernyő jobb szélén található $ 5 \times 5 $ mezőből álló síktábla pedig a kocka legtávolabbi sorait, amelyen sötét tisztjei találhatóak az alapállásban. Így a képernyőn felfelé és lefelé mutató irány a térbeli sakktáblán is felfelé illetve lefelé mutat. 

A táblák fölött és mellett látható az eligazodást segítő jelölés ("ABCDE" a szintek, "abcde" a vonalak és "12345" a sorok jelölésére). Az egérmutatót az egyes mezők fölé mozgatva a tábla alatt megjelenik az adott mező jelölése (például Ac4 vagy Db3).

\subsection{A lépés}

Egérkattintás segítségével a soron következő játékos bábui kiválaszthatóak. Amennyiben a bábunak vannak lépési lehetőségei, ezek színezés segítségével megjelennek a táblán. Ha a játékos meggondolja magát, és inkább másik bábuval szeretne lépni, a korábban kiválasztott bábura ismét kattintva a kijelölés megszűnik, és ezután új báb választható. Amikor kijelöltünk egy bábut lépésre, majd egy átszínezett mezőre kattintunk, ahova a kijelölt bábu a játék szabályai szerint léphet, a lépés megtörténik, és ezután a másik játékos következik.

Nem lehet olyat lépni, aminek a következtében a királyunk sakkba kerülne, és ha a királyunk sakkban van, akkor lépésünkkel meg kell szüntessük a sakkot. Ha ez nem lehetséges, mattot kaptunk, ezt a program kijelzi. Amennyiben a királyunk nincsen sakkban, de semmilyen szabályos lépést nem tudunk tenni, ez patt, vagyis döntetlen, a program ezt is kijelzi\footnote{A hagyományos sakkban a patton kívül más módokon is létrejöhet döntetlen, például amennyiben ugyanaz az állás egymást követően háromszor létrejön a táblán, a bírótól döntetlen kérhető. Az ilyen döntetlenek lehetőségeivel a program nem foglalkozik.}.

Amennyiben egy gyalogunkkal belépünk az ellenfél tisztjeinek bázisára, gyalogunk automatikusan vezérré alakul át.

\section{Visszajátszás}

Bármikor, amikor egy játszma során bezárjuk az alkalmazást, az összes addigi lépés elmentésre kerül a "lastspacechessgame.txt" elnevezésű állományba. Ezt az állományt archiválási céllal átnevezhetjük, illetve az "-r" argumentummal indítva a programot a játszmát visszanézhetjük. A visszajátszás során megjelenik a grafikus felhasználói felület, a táblán a kezdőállással. A jobb oldali egérgombbal bárhol kattintva a játszma történetében egy lépést haladhatunk előre, vagyis megnézhetjük a következő lépés eredményét. A bal oldali egérgombbal kattintva az egy lépéssel korábbi állapotot kapjuk. Így oda-vissza végignézhetjük a játszma lépéseit.

\section{Játék hálózaton}

A hálózati játék során két, egymással TCP/IP hálózati kapcsolatban álló számítógépen két külön Spacechess program kommunikál. Ennek menete a következő:

Először elindítjuk a kiszolgálót az "-s" parancssori argumentummal. Megjelenik a grafikus felhasználói felület, és a program jelzi, hogy csatlakozásra vár.

Ekkor a másik játékos elindítja a csatlakozó szoftvert a "-c" argumentummal. Ha a csatlakozás sikeres, a játszma elindul. A csatlakozó játékos játszik világossal, így övé az első lépés. Amikor ezt megtette, a lépés megjelenik mindkét játékos számítógépén, és most sötéten a lépés sora. A lépés megtételének módja megegyezik a helyi játszmánál használható módozattal: a léptetni kívánt bábot kijelöljük, majd a célmezőre kattintunk, stb.

\chapter{Fejlesztői dokumentáció}

A Fejlesztői dokumentáció tartalmazza 
\begin{itemize}
\item a probléma részletes specifikációját, 
\item a felhasznált módszerek részletes leírását, a használt fogalmak definícióját,
\item a program logikai és fizikai szerkezetének leírását (adatszerkezetek, adatbázisok, modulfelbontás),
\item a tesztelési tervet és a tesztelés eredményeit.
\end{itemize}


\section{A szoftver informális specifikációja}

A szoftver célja, hogy a Térsakk játékot szimulálja, a Térsakk tábláját és bábuit virtuálisan megjelenítse, és segítségével két személy helyben egy számítógépen, vagy hálózaton keresztül két számítógépen Térsakk játszmákat játszhasson le. Célja továbbá, hogy a játszott játszmák archiválásra kerüljenek, és a szoftver segítségével vissza\-néz\-he\-tő\-ek legyenek.

Ezek a tevékenységek a felhasználó szemszögéből a következő UML diagramokkal írhatók le.

[ Felhasználói esetek diagramokkal ]

\section{A használt fejlesztői eszközök és módszerek}

\subsection{C++11}

A szoftver fejlesztése során elsődleges szempont volt, hogy a programot a lehető legtöbb számítógépen futtatni lehessen, vagyis a lehető legnagyobb mértékű platformfüggetlenség. Szempont volt továbbá a hatékonyság, hogy (jövőbeli fejlesztési lehetőségként) adott esetben kis számítási kapacitással rendelkező eszközökön (például mobiltelefonokon) is jól működjön a program. Ezért az implementáláshoz a C++ programozási nyelv 2011-es ISO szabványára (a továbbiakban C++11) esett a választás, mivel ez mind a széles körben elérhetőség, mind a hatékonyság követelményeinek megfelel. A program készítése során igyekeztem elsődlegesen a C++11 eszközeit használni, vagyis ha egy feladat megoldható a C++11 segítségével, akkor nem használtam harmadik fél által kínált programkönyvtárakat.

Ahogy haladtam a program fejlesztésével, a C++11 szabványnak egyre több szol\-gál\-ta\-tá\-sát ismertem meg. A fejlesztés során igyekeztem folyamatosan hasznosítani az új ismereteket. Például míg eleinte konstruktorok segítségével inicializáltam a különböző objektumokat, később átálltam az egységes inicializáló-listák használatára. Vagy míg eleinte a \emph{new} kulcsszó segítségével inicializáltam a smart-pointereket, később átálltam a \emph{std::make\_shared\textless\textgreater()} sablonfüggvény használatára. Ennek köszönhetően azonban a C++ nyelv használata nem lett egységes a forrásszövegben, még a folyamatos refaktorálás ellenére sem.

A fejlesztés során igyekeztem szem előtt tartani a \cite{codingrules} és \cite{effective} könyvekben bemutatott szempontokat. Különösen odafigyeltem a RAII (Resource Allocation Is Initialization) elv betartására \cite{raii}. Kiterjedten alkalmaztam smart pointereket, elsősorban a standard könyvtár shared\_ptr sablonját. Minden olyan esetben, ahol egy függvény iterált adatszerkezetet fogad paraméterül, vagy ad visszatérési értékül, a megvalósításban az iterált szerkezetre mutató smart pointer szerepel. Mivel ez implementációs részlet, erre a program szerkezetének leírásában ezután nem térek ki, vagyis például ahol listáról írok, ott a megvalósításban egyaránt állhat lista, vagy egy listára mutató smart pointer. Azonban egyszerű mutatókkal dolgoztam azokban az esetekben, ahol egy objektum egy másik objektummal ismeretségi viszonyban van, azonban nem "birtokolja" azt. Amikor például azt írom, hogy a GameEvent osztály ismeri a Game-et, ez azt jelenti, hogy a GameEvent osztály a konstruktorában kap egy Game típusú objektumra mutatót pointert, hogy a Game típusú objektumot meg tudja szólítani.

A hibakezelés során törekedtem kivételkezelés alkalmazására. A kiváltott kivételek minden esetben a std::exception leszármazottjai. Nem készítettem saját kivételosztályokat, hanem a szabvány könyvtár készletéből gazdálkodtam. Például amikor egy paraméterként kapott leíró sztring hibás formátumú, akkor invalid\_argument kivétel keletkezik. Az alacsonyabb szinteken keletkező kivételeket magasabb szinteken elkaptam, és adott esetben új, a hiba helyét és jellegét jobban körülhatároló kivételekkel helyettesítettem. A kivételek minden esetben szöveges tájékoztatást tartalmaznak a hibáról.

\subsection{SFML}

Szintén a hatékonyság és a platformfüggetlenség kívánalmának akarván megfelelni, a grafikus felhasználói felület megvalósításához az OpenGl szabványra esett a választásom. Mivel azonban az OpenGl igényel valamilyen köztes réteget az alkalmazás és az operációs rendszer között (például önmagában nem tartalmaz ablakkezelést), a Simple and Fast Muldimedia Library (továbbiakban SFML) nyílt forráskódú programkönyvtár se\-gít\-sé\-gé\-hez fordultam \cite{sfml}. Mint kiderült, az SFML erősen objektumorientált szemléletű, és azon túl, hogy lehetőséget ad OpenGl programok írására, önmagában is rendelkezik magasabb szintű grafikus képességekkel, amelyek a program elkészítéséhez elégnek bizonyultak. Így aztán az OpenGl közvetlen programozására az alkalmazásban nem is került sor. 

Az SFML azon túl, hogy biztosítja az ablakkezelést és egyszerű grafikus műveleteket, az egér kezelését is egyszerűvé teszi, továbbá tartalmaz egy hálózati modult, amivel az operációs rendszer hálózati szolgáltatásait elfedi. Így az operációs rendszer szolgáltatásait a fájlkezelést illetően a C++11 szabvány könyvtára, az összes többi szolgáltatást illetően pedig az SFML elfedi. Az SFML mind GNU/Linux, mind Microsoft Windows, mind Apple OS-X környezetben működik, így használatával a platformfüggetlenség nagy mértékben megvalósult, a Spacechess program forráskódja lé\-nye\-gé\-ben változtatások nélkül\footnote{Apróbb változtatásokra szükség lehet, mivel a különböző fordítóprogramok a C++11 szabványt különböző mértékben valósítják meg.} lefordítható az említett platformokon. 

\subsection{CMake}

Mivel a Spacechess program nagyszámú forrásfájlból áll, szükségem volt egy egységes, több platformon is működő \emph{build}-rendszerre, amely a forrásfájlokból a megfelelő bináris állományokat elkészíti. Erre a célra a nyílt forrású CMake rendszert használtam \cite{cmake}. A CMake egy úgynevezett meta-build rendszer. A forráskód mappáiban elhelyezett {\tt CMakeList.txt} állományok a CMake saját programnyelvén\footnote{A CMake programnyelve leginkább a shell scriptek nyelveihez hasonló.} leírják, hogy a for\-rás\-fáj\-lo\-kat hogyan kell lefordítani. A CMake program ez alapján készíti el az adott platform és fejlesztőkörnyezet egyedi build állományait, például GNU/Linux esetén \emph{Makefile} állományokat, vagy Microsoft Visual Studio esetén a fordítás szerkezetét leíró \emph{Solutiont}. Ezután az adott fejlesztőeszköz végzi el a fordítást.

A Spacechess program kapcsán a CMake elemi használatához elég azt tudni, hogy amennyiben új C++ forrásállományt ({\tt *.cpp}) hozunk létre, annak nevét a tartalmazó mappa {\tt CMakeList.txt} állmányában a \emph{SOURCES} változó értékeként fel kell sorolni a fordításhoz.

\subsection{Catch}

A szoftver fejlesztése során célszerűnek tűnt az egyes részek működését automatikus teszteléssel biztosítani. Ehhez szükségem volt egy könnyek kezelhető tesztelési keretrendszerre. Némi tájékozódás után a Catch nevű eszközre esett a választás \cite{catch}. A Catch egyetlen \emph{header} állományból áll, aminek következtében nagyon hamar üzembe tudtam állítani. A tesztfájlok a forráskód Tests almappájába kerültek, és első utasításként behívják a catch.hpp állományt. A tesztek lefordításához a forráskódhoz hasonlóan a CMake rendszer használatos. A fordítás során egy Tests nevű futtatható állomány keletkezik, amelyet végrehajtva az összes tesztünk ellenőrzésre kerül.

A tesztek forráskódja szabvány C++ szöveg néhány makróval kiegészítve. A SCENARIO makró segítségével teszteseteket adhatunk meg. A teszteseteken belül megadhatunk környezeteket a GIVEN, WHEN és THEN makrókkal, melyek azonos funkcionalitással bírnak, és tetszőleges mélységben egymásba ágyazhatóak. Az alacsonyabb szinten lévő környezetben történő változások egyáltalán nincsenek kihatással a magasabb szinten lévő környezetre, így azonos környezetet biztosíthatunk több különböző, egymás után végrehajtandó teszt számára, ha az előkészítést magasabb szinten, az egyes tesztesetek vizsgálatát alacsonyabb szinten végezzük el. Megadhatunk továbbá a programra vonatkozó logikai állításokat a REQUIRE makró paramétereként, ezek igaz volta kerül ellenőrzésre a teszt futtatása során.

A SCENARIO, GIVEN, THEN, WHEN makrók célja a Catch rendszerben a tesztvezérelt fejlesztés lehetővé tétele. Amennyiben erre nincs szükség, a Catch használata még egyszerűbb lehet. A SCENARIO makró helyett használható az azonos funkcionalitású TEST\_CASE makró, és a GIVEN, THEN, WHEN makrók helyettesíthetőek a SECTION makróval, amely tetszőleges mélységben tartalmazhat további SECTION makrókat. További tesztek készítéséhez ezt az egyszerűbb megközelítést javaslom.

\subsection{További felhasznált eszközök}

A fejlesztést elsődlegesen Ubuntu GNU/Linux rendszeren végeztem. Fejlesztői környezetnek a nagyszerű KDevelop integrált fejlesztőrendszert használtam. A sakkbábuk képfájljait az Inkscape program segítségével szabtam a program igényeihez. Az eredeti képfájlokat Uray Marcell János készítette és tette szabadon felhasználhatóvá. A programban használt betűtípus szintén szabadon felhasználható, és az SFML példaállományaiból származik. A Microsoft Windows alatt működő változat a Visual Studio Community 2013 verziójával került lefordításra.

\subsection{Módszertan}

A program fejlesztése során több fejlesztési és projekt-kivitelezési módszertant is kipróbáltam. Folyamatosan törekedtem az objektum-orientált fejlesztési elvek minél teljesebb elsajátítására. A fejlesztés iteratív folyamat volt, amelyben tervezési szakaszokat kódolási szakaszok váltottak. A tervezést többnyire UML diagramok készítése jelentette. A kódolási szakaszban a diagramok alapján készítettem kódot, azonban az eközben felmerülő problémákra már kódban kerestem megoldást. Amikor kezdtem elveszteni a tájékozódást a kódban, az alapján frissítettem az UML diagramokat, és ismét az UML szintjén végeztem a tervezést. Körülbelül nyolc ilyen tervezés-kódolás iterációt csináltam végig.

A projekt menedzselése során egy agilisnek tekinthető módszert, a SMART módszertant követtem. Ennek keretében két-három hetes időszakokra egyszerűbb, jól körülhatárolt, reálisan megvalósítandó célokat tűztünk ki a konzulensem segítségével, melyeket írásban rögzítettem. Bár a határidőket időnként nem sikerült tartanom, a módszer tervezhetősége folytán lehetőséget adott a korrekciókra.

Az agilis fejlesztési módszerek alkalmazásában nagyon nagy hatással volt rám a \cite{cleancode} könyv. Ennek eredményeképpen jelentek meg a kódban nagy számban a különböző részfeladatokat ellátó privát eljárások. Ennek köszönhető, hogy a kódban nagyon kevés megjegyzés maradt, helyettük a függvények és változók hosszú, beszédes neveket kaptak annak érdekében, hogy szerepük és funkciójuk megjegyzések nélkül is tisztán és világosan érthetővé váljon a kód olvasója számára. A programot folyamatosan refaktoráltam, hogy minél egyszerűbbé, minél érthetőbbé váljon a forráskód.

\section{A program logikai szerkezete}

A Spacechess program megvalósításához a Modell-Nézet-Vezérlő architektúrát választottam. A három modul kezdetben nagyon elvált egymástól, a Nézet csak a Vezérlőn keresztül kommunikált a Modellel. Ez nehézkesnek bizonyult, ezért létrehoztam a Modell számára egy csak olvasható interfészt, és a Nézet immár ezen keresztül közvetlenül is lekérheti a Modell állapotának részleteit. A három modul három különböző névtérben helyezkedik el.

\subsection{A vezérlés}

A {\tt main} függvény és az alkalmazás osztály kivételével az összes vezérlési osztály a Controller névtérben kapott helyet.

\subsubsection{A program belépési pontja}

A program belépési pontja a {\tt main} függvény, ami mindösszesen létrehoz egy alkalmazás (App) objektumot, és delegálja a parancssori paramétereket számára.

\subsubsection{Az App osztály}

Az App osztály létrehozza a grafikus felhasználói felület ablakát ({\tt setUpWindow} metódus), és a parancssori paraméterek függvényében a megfelelő vezérlő objektumot ({\tt setUpAGameController} metódus). Amennyiben a parancssori paraméterek nem megfelelőek, erről tájékoztatást ad ({\tt showUsage} metódus), majd a program kilép.

\subsubsection{A GameController osztály és leszármazottai}

A GameController osztály leszármazottai biztosítják a program különféle működési módjainak vezérlését. 

A GameController osztály öröklődő attribútuma a Modell játszmát leíró osztályának (Game) egy példánya, továbbá a Nézet grafikus megjelenítésért felelős osztályának (Render2D) egy példánya. A Vezérlő és a Nézet közötti belső üzenetküldésre használatos az EventQueue osztály által megvalósított, belső eseményeket leíró üzenetsor. 

A GameController osztály három absztrakt metódust tartalmaz. Ezek a {\tt mainLoop}, amelyben a vezérlési ciklust kell megvalósítani, a {\tt handleSystemEvents}, amely az SFML által közvetített rendszeresemények lekezelését szolgálja, és a {\tt handleGameEvents}, amelyben a belső üzenetsor (EventQueue) eseményeit kezeljük le. Az App osztály a \break GameController valamely leszármazottjának {\tt mainLoop} metódusának adja át a vezérlést.

\subsubsection{A PlaybackController osztály}

A PlaybackController osztály a játszmák visszajátszásának vezérlését valósítja meg. A konstruktor végrehajtása során a {\tt loadGame} metódus fájlból betölt egy játszmát. A rendszeresemények kezelése során ({\tt handleSystemEvents}) a bal és jobb egérgomb hatására egy-egy üzenet kerül a belső üzenetsorra. A {\tt handleGameEvents} metódus ezeket az üzeneteket feldolgozza, és lefordítja a Modell metódushívásaira. A {\tt mainLoop} metódus a kétféle eseménykezelőt futtatja, illetve frissíti a Nézet állapotát.

\subsubsection{A LocalGameController osztály}

A LocalGameController osztály a helyi játék lebonyolításáért felelős. A rendszeresemények kezelése során ({\tt handleSystemEvents}) közvetíti az egérkattintás esemény tulajdonságait (az egér pozícióját) a Nézet számára. A Nézet megvizsgálja, hogy mely megjelenített elemen következett be az egérkattintás, és ennek megfelelően Event üzeneteket tesz a belső üzenetsorra. Az üzenetek feldolgozását a LocalGameController a PlayerController osztálynak delegálja ({\tt handleSelection}). A PlayerController különbséget tesz első és második kattintás között ({\tt handleFirstSelection} és {\\handleSecondSelection} metódusok), vagyis menedzseli a bábuk és a lépés célmezőjének kiválasztását. A PlayerController ismeri a Nézetet, és kérvényezi tőle a kiválasztott bábu alatti mező, illetve a lehetséges lépések célmezőinek vizuális kiemelését. A PlayerController elkéri a játszmát reprezentáló Game objektumtól az aktuálisan megtehető lépések listáját. Amennyiben a játékos legális lépést kezdeményezett, a PlayerController továbbítja ezt a kérést a Game objektum számára. A LocalGameController {\tt mainLoop} metódusa a külső és belső események feldolgozása után frissíti a Nézetet, és kilépéskor a {\tt saveGame} metódus hívásával fájlba menti a játszmatörténetet.

\subsubsection{A NetworkGameController osztály}

A NetworkGameController a hálózati játék működtetéséért felelős. Mivel sok átfedést tartalmaz a LocalGameController funkcionalitásával, annak leszármazottja. A NetworkGameController konstruktorban megkapja, hogy kiszolgáló vagy kliens üzemmódban működik-e, valamint a hálózati paramétereket. 

A hálózati kapcsolat felépítését a ConnectionBuilder osztálynak delegálja, amely szintén konstruktorparamétereken keresztül kapja meg a működési módot és a hálózati paramétereket. A ConnectionBuilder kiszolgáló oldalon várakozni kezd ({\tt startListening}), majd a csatlakozási kérelmet fogadja ({\tt acceptConnection}). Kliens oldalon az osztály csatlakozni próbál egy kiszolgálóhoz ({\tt connectToServer} metódus). A csatlakozás kétféle menetét elfedi az {\tt establishConnection} metódus. A {\tt getInfoMessage} függvény egy sztringben tájékoztatást ad a csatlakozás aktuális állapotáról. A sikeres csatlakozás eredménye mindkét üzemmódban egy kommunikációra kész, az SFML által biztosított sf::TcpSocket objektum.

A NetworkGameController osztály a NetworkPhase enumeráció segítségével nyomon követi a hálózati kapcsolat állapotát. A {\tt mainLoop} metódusa a rendszeresemények kezelésén túl kiegészül a {\tt handleConnections} metódus hívásával, ami a kapcsolat kezeléséért felelős. A {\tt handleConnections} kommunikál a ConnectionBuilder objektummal, valamint működő kapcsolat esetén továbbadja a vezérlést az üzeneteket fogadó és feldolgozó {\tt handleCommunication} metódusnak, ami lefordítja a hálózati üzeneteket a Modell metódusainak hívásaira. A belső üzenetsor feldolgozását végző {\tt handleGameEvents} metódus kiegészül a {\tt sendMove} metódus hívásával, amennyiben helyi lépésre kerül sor. A {\tt sendMove} elküldi a lépést a hálózati kapcsolaton keresztül a másik fél számára. 

A NetworkGameController tudja, hogy melyik játékos a helyi játékos (localPlayer attribútum), és a helyi események feldolgozását csak akkor végzi el, ha a helyi játékos van soron ({\tt localPlayerIsNextPlayer}). Ellenkező esetben a hálózatról várja a következő lépést. Kilépés előtt ez az osztály is elmenti a játszmatörténetet.

\subsection {A játékmodell}

A játszmák logikai működését szimuláló Modell osztályai a Model névtérbe kerültek. A Modell a következő alapfogalmakkal dolgozik.

\subsubsection {Player}
A Player enumeráció segítségével a játékosokra lehet hivatkozni.

\subsubsection{Figure}
A Figure enumeráció a Térsakk játék különböző figuráit sorolja fel.

\subsubsection{Position}
A Position osztály a 3 dimenziós sakktábla egy mezőjét jelöli ki. Ezen túl lehetőséget nyújt a szomszédos pozíciók meghatározására egy adott mezőhöz képest az {\tt over, under, right, left, farther, closer} metódusok segítségével, mely irányok a világos játékos oldala felől értendőek. Ezek a metódusok egy új Position objektumot adnak vissza, ami ismét rendelkezik ilyen metódusokkal, tehát például egy huszár egy lehetséges lépését leírhatjuk a {\tt position.farther().farther().left()} kifejezéssel. Position objektumot létrehozhatunk úgy is, hogy számszerűen megadjuk, melyik szinten, melyik vonalon és melyik sorban legyen a pozíció, de az osztály túlterhelt konstruktora elfogadja a játékban használatos három jelből álló pozícióleírást (például "Cc3" vagy "Ad2") is egy sztringben. A Position osztály megvalósítja a $<$ összehasonlító operátort, hogy használható legyen rendezést kívánó szabványos konténerekben.

\subsubsection{A Piece osztály és leszármazottai}

A Piece egy absztrakt osztály, melynek leszármazottai  az egyes figurák viselkedését adják meg. A Piece osztály a statikus {\tt generatePiece} metódus segítségével generálja a különböző bábu-objektumokat. A {\tt generatePiece} metódus egy bábu-leíró sztringet és egy, a táblára mutató mutatót vár paraméterül. A bábu-leíró sztring formátuma a következő:
\begin{itemize}
	\item az első karakter kisbetűs 'w' vagy 'b' attól függően, hogy világos vagy sötét figurát szeretnénk,
	\item a második karakter a nagybetűs 'K', 'Q', 'R', 'B', 'N', 'U', 'P', amely rendre királyt, vezért, bástyát, futót, huszárt, unikornist és gyalogot jelöl,
	\item a következő három karakter a figura pozícióját adja meg a játéktábla jelölésével (például "Bc4" vagy "Ee5").
\end{itemize}
Amennyiben a bábu-leíró sztring formátuma hibás, invalid\_argument kivétel keletkezik.

A Pieceből származott objektumok ismerik a játékost, amelynek bábui ({\tt getPlayer}), meg tudják mondani, hogy hol helyezkednek el a táblán ({\tt getPosition}), és hogy milyen figurák ők ({\tt getFigure}). Ennél többet is tudnak azonban, meg tudják mondani, hogy mely mezőkre léphetnek ({\tt getPossibleMoves} metódus), illetve mely mezőkön tudnak ütni ({\tt getPossibleTakes} metódus). Ez utóbbi három metódust a leszármazottak értelemszerűen felüldefiniálhatják. Mivel a lehetséges lépések pozíciói csak a gyalog esetén térnek el a lehetséges ütések pozícióitól, a Piece osztály {\tt getPossibleTakes} metódusa közös, megfelelő alapértelmezett működést biztosít a többi figura számára.

Mivel a lehetséges lépések és ütések meghatározása során olyan tevékenységekre van szükség, amelyek kettő vagy több figura esetén megegyeznek, a Piece osztály nagyszámú védett segédfüggvényt bocsát a tőle öröklődő osztályok rendelkezésére. Ezek a következők:
\begin{itemize}
	\item A logikai értékkel visszatérő {\tt canMoveTo, canTakeAt, canMoveToOrTakeAt} függvények megadják, hogy egy adott pozíció üres-e, az ellenfél bábuját tartalmazza-e, illetve ezek közül valamelyik teljesül-e.
	\item A {\tt filterForOnBoard}, {\tt filterForMove}, {\tt filterForTake}, {\tt filterForMoveOrTake} eljárások egy pozíciókból álló listát várnak paraméterül, és különböző feltételek szerint megszűrik azokat, vagyis a listáról kitörlik azokat a pozíciókat, amelyek nem felelnek meg egy adott feltételnek. 
		\subitem A {\tt filterForOnBoard} eljárás a táblára eső pozíciókat hagyja a listában. Erre azért van szükség, mert a pozíciók közötti navigálás során (a Position osztály {\tt over, under, left, right, farther, closer} metódusai segítségével) előfordulhat, hogy lemegyünk a tábláról. 
		\subitem A {\tt filterForMove} eljárás azokat a pozíciókat hagyja a listában, amelyre a báb ütés nélkül léphet.
		\subitem A {\tt filterForTake} eljárás azokat a pozíciókat adja meg, amelyeken ütni lehetséges, vagyis amelyeken az ellenfél bábuja áll.
		\subitem A {\tt filterForMoveOrTake} a fenti két eljárás értelemszerű kombinációja.
	\item A {\tt moveOrTakeStraightFrom}, a {\tt moveOrTakePlaneDiagonallyFrom} és a \break {\tt moveOrTakeTrueDiagonallyFrom} függvények azon bábok mozgásának leírásához nyújtanak segítséget, amelyek egy adott pozícióból egy adott irányba tetszőleges számút léphetnek. A függvények az megadott pozícióból elindulva sorra megvizsgálják, hogy az adott irányokba haladva szabad-e az út a bábu előtt, illetve lehetséges-e az ellenfél egy bábuját kiütni. Mindhárom függvény az elérhető pozíciók listáját adja visszatérési értékként. A {\tt moveOrTakeStraightFrom} függvény a bástya mozgásának irányait vizsgálja, a tábla síkjaira merőleges irányokat. A {\tt moveOrTakePlaneDiagonallyFrom} függvény a tábla síkjaiban átlós mozgással elérhető mezőket eredményezi. A {\tt moveOrTakeTrueDiagonallyFrom} függvény az Unikornis mozgási lehetőségeit számolja ki. A Vezér mozgási lehetőségeit e három függvény eredményeinek uniója alkotja.
	
	Hogy e három függvényt megvalósítsa, a Piece osztály definiál még két segédeljárást.
	\subitem Az {\tt addPositionsFromSourceInDirection} eljárás egy adott pozícióból egy adott irányba elhelyezkedő pozíciókat adja hozzá egy már meglévő pozíciólistához. Az eljárás érdekessége, hogy az irány fogalmát egy Position objektumból Position objektumot létrehozó függvény (DirectionFunction) segítségével ragadja meg. Az elemi irányfüggvényeket a Position osztály már definiálta, ezekből összetett irányfüggvényeket pedig lambda-kifejezések segítségével definiálhatunk.
	\subitem Az {\tt addPositionsFromSourceInManyDirections} eljárás annyiban tér el az előzőtől, hogy nem egyetlen irányfüggvényt, hanem irányfüggvények listáját várja paraméterül. A listát feldolgozza, és az összes megadott irányba leellenőrzi, hogy meddig lehetséges a lépés.
\end{itemize}
A Piece osztály segédfüggvényeinek megvalósításánál igen hasznosnak bizonyultak a funkcionális programozás terén folytatott tanulmányaim.

A Piece osztály leszármazottjai a King, a Queen, a Knight, a Bishop, a Rook, az Unicorn és a Pawn osztályok. Többségük csak a {\tt getFigure} és {\tt getPossibleMoves} metódusokat definiálja felül.

\subsubsection{A Board osztály}

A Board osztály biztosítja a játéktábla belső reprezentációját. A táblát egy szótár (std::map) adatszerkezettel írja le, melyben a kulcsok Position objektumok, az értékek pedig Piece objektumokra mutató pointerek. Ez az adatszerkezet nagy hatékonysággal valósítja meg a pozíció alapú bábukeresést, amelyre a sakk- és mattvizsgálat során nagy számban van szükség.

A Board osztály lehetővé teszi, hogy hozzáadjunk egy bábut a táblához ({\tt addPiece} metódus), eltávolítsunk egy bábut a tábláról ({\tt removePiece} metódus), lekérjünk egy bábut egy adott pozícióról ({\tt getPiece} metódus), megállapítsuk egy pozícióról, hogy van-e rajta báb ({\tt isOccupied} metódus). Ezen felül lehetőségünk van egy adott játékos adott figuráját megkeresni a táblán ({\tt find} metódus, amely egy pozícióval tér vissza), illetve az adott játékos összes még játékban lévő bábuját is lekérhetjük ({\tt getAllPiecesFor} metódus). A {\tt getFullBoard} metódus segítségével pedig egy olyan reprezentációját kapjuk a táblának (Fullboard struktúra), amelyet a Nézet könnyen meg tud jeleníteni.

\subsubsection{A GameEvent osztály és leszármazottai}

A GameEvent osztály a játszma egy eseményét reprezentálja a Modellben. Ilyen események például a játszma kezdete, vagy egy lépés megtétele. A GameEvent osztály a Command programfejlesztési mintán alapul \cite{designpatterns}. Minden GameEvent objektum rendelkezik egy mutatóval, amely az aktuális játszmát reprezentáló Game osztály példányára mutat. Ezen mutatón keresztül a GameEvent objektumok különböző módosításokat tehetnek a játszma reprezentációján.

A GameEvent osztály három absztrakt metódust tartalmaz, ezek az {\tt execute}, a {\tt revert} és a {\tt getNotation}. Az {\tt execute} metódus segítségével a játszmaesemény (például lépés) végrehajtásra kerül. A {\tt revert} metódus megpróbálja visszaállítani az esemény előtti állapotot. E két metódus segítségével a játsz\-ma\-tör\-té\-net\-ben lépkedni lehet.

A GameEvent osztály felelős azért is, hogy az általa reprezentált játszmaeseményről információt adjon. Az említett {\tt getNotation} metódus visszaadja az esemény jelölését egy sztringben. A {\tt getPlayer} metódus megadja az esemény során cselekvő játékost (ez akár Nobody értékkel is bírhat, például a játszma elindítását reprezentáló esemény esetében). A {\tt getMoveNumber} megadja, hogy az esemény a játszmatörténetben hanyadik lépésnél következik be.

A GameEvent osztály {\tt generateMove} statikus metódusával generálhatunk Move objektumokat, melyek a GameEvent leszármazottjai. A metódus vagy két pozíciót (honnan és hova), vagy egy lépést leíró sztringet vár paraméterül, továbbá egy mutatót az aktuális játszmát leíró Game objektumra. A lépést leíró sztring formátuma a következő:
\begin{itemize}
	\item az első három karakter annak a pozíciónak a játékbeli jelölése, amelyről lépni szeretnénk,
	\item ezt egy szóköz követi,
	\item az utolsó három karakter pedgi annak a pozíciónak a leíró jelölése, ahova lépni akarunk.
\end{itemize}
Egy lehetséges lépést leíró sztring például az "Aa1 Bb2", vagy a "Cc3 Bc5".

\subsubsection{A History osztály}

A History osztály kezeli a játszmatörténetet. Belső reprezentációja egy GameEvent objektumokra mutató pointerekből álló vektor. A History osztály tartalmaz egy mutatót az őt attribútumként tartalmazó, a játszmát reprezentáló Game osztályra. Ezen mutatón keresztül tudja a játszma belső reprezentációját megváltoztatni. A History osztályt érdemes úgy elképzelni, mint egy GameEvent objektumokból álló listát. A History objektumnak van egy aktuális eleme, amely legutoljára végrehajtásra került. A History létrejöttekor automatikusan tartalmaz egy Creation objektumot, amely a GameEvent osztály leszármazottja, és a játszma kezdetét jelöli. A játszmatörténethez ezután az {\tt addEvent} metódussal adhatunk hozzá eseményeket. A {\tt reset} metódus a játszmatörténet elejére ugrik, az {\tt actualize} metódus pedig a végére, vagyis végrehajtja a listában található összes eseményt. A {\tt stepForward} és {\tt stepBack} metódusokkal lépdelhetünk előre illetve hátra a játszmatörténetben. A {\tt clearFuture} metódus törli az összes olyan eseményt, amely az aktuális esemény után szerepel még a listában.

A {\tt getCurrentEvent} metódussal lekérhetjük az utolsó végrehajtott eseményt. A {\tt getPlayerForLastEvent} és a {\tt getMoveNumberForLastEvent} az utolsó eseményben érintett játékost, illetve a lépés számát adja vissza. Ez utóbbi számozás a sakkban szokásos módon történik, vagyis nem az egyes lépések, hanem világos-sötét lépéspárok kerülnek számozásra. A {\tt getNextPlayer} metódus megadja az aktuálisan soron következő játékost.

Egy History objektum szövegfolyammá alakítható, illetve szövegfolyamból beolvasható a folyamokon felüldefiniált $<<$ és $>>$ operátorok segítségével.

\subsubsection{A Judge osztály}

A Judge osztály a játszma aktuális állásában legális lépések, valamint a sakk, patt és matt megállapítására szolgál. Ezen tevékenységekhez a Judge osztály igénybe veszi az aktuális játszmát reprezentáló Game osztálytól elkért Board és History objektumok szolgáltatásait. A Game osztály aktuális példányát a Judge osztály konstruktorparaméteren, egy mutatón keresztül kapja meg.

A Judge a következő publikus szolgáltatásokat nyújtja:

\begin{itemize}
	\item Az {\tt isValidMove} logikai függvény megmondja, hogy egy pozíció-pár által megadott lépés szabályos-e.
	
	\item Az {\tt isInCheck} logikai függvény megmondja, hogy a paraméterként kapott játékos királya sakkban van-e. Ehhez lekérdezi a Board objektumtól a király pozícióját, illetve a másik játékos összes bábuját egy listába. A bábuk listáján lineáris keresés segítségével olyan bábut keres, amelynek ütési lehetőségei között szerepel a király pozíciója.
	
	\item a {\tt getCurrentlyPossibleMovesFrom} metódus egy pozíciót kap paraméterül,  és egy listában megadja, hogy a soron következő játékos az adott pozíción lévő bábuval mely helyekre léphet. Amennyiben az adott pozíción nincs a soron következő játékosnak bábuja, nullptr-t kapunk vissza. A Judge a lehetséges lépések meghatározásánál az adott figurák elhelyezkedésén és képességein túl figyelembe veszi azt a szabályt, hogy a király nem kerülhet sakkba a lépés következtében, valamint ha sakkban van, akkor csak az számít érvényes lépésnek, aminek következtében a sakk megszűnik.
	
	Utóbbi megállapításához a Judge osztály a {\tt filterTargetsForNotInCheckAfter} függvényt alkalmazza. Ez a függvény paraméterül megkapja a kiindulási pozíciót, valamint az összes elérhető pozíció listáját. Ebből a listából egy szótárt készít, amelyben a célpozíció adja a kulcsot, értékként pedig minden egyes célpozícióhoz legenerálja a lépést megvalósító GameEvent objektumot. Ezután a History objektumot hívja segítségül a lépés utáni helyzet vizsgálatához a következő algoritmussal: létrehoz egy új, üres listát a legális célpozícióknak, majd végigiterál a szótár összes elemén, és az adott Move játékeseményt hozzáadja a játszmatörténethez, majd végrehajtja azt. Az új helyzetben az {\tt isInCheck} függvény segítségével megvizsgálja, hogy a lépést követően sakkban van-e a király, és amennyiben nem, a lépés legális, a szótár kulcsát, azaz a célpozíciót hozzáveszi a szabályos célpozíciókat tartalmazó listához. A ciklus magja ezután a visszalép a játszmatörténetben, és a hozzáadott Move eseményt törli a történet végéről. A ciklus végén a függvény visszatér a legális lépéseket tartalmazó listával. 

	\item A {\tt canMove} metódus megadja, hogy a paraméterként kapott játékos tud-e egyáltalán legális lépést tenni. Segítségével állapítható meg a matt, illetve a patt. A metódus lekéri a Board objektumtól a játékos összes bábuját, majd a listán egy lineáris keresést hajt végre. A lineáris keresés során azt vizsgálja, hogy az adott bábu által legálisan megtehető lépések listájának van-e legalább egy eleme. A vizsgálat során nem a Piece objektum {\tt getPossibleMove} eljárására támaszkodik, hanem a Judge saját {\tt getPossibleMove} megvalósítására, amely tartalmazza a lépés utáni sakk-ellenőrzést is.
	
	A {\tt canMove} a Modell leginkább műveletigényes metódusa. A művelet végrehajt egy lineáris keresést, amely a játékos bábuinak száma (j) függvényében $O(j)$ műveletigényű. Azonban a keresés feltételében szerepel a Judge {\tt getPossibleMoves} művelete, amely a bábu által megtehető összes lépésre (k) ellenőrzi, hogy utána sakkban van-e a játékos. Mivel a sakk ellenőrzésekor két egymásba ágyazott lineáris keresést hajtunk végre (az ellenfél játékosai (l darab) által megtehető ütő lépések (m darab), az {\tt isInCheck} metódus $O(l \times m)$ műveletigényű. Ennélfogva a {\tt getPossibleMoves} műveletigénye $O(k \times l \times m)$, és a {\tt canMove} műveletigénye $O(j \times k \times l \times m)$ lesz. Azonban a valós műveletigényt a bábuk száma, a tábla véges mérete, illetve az egyes bábuk által egy lépésben elérhető mezők száma kellően alacsonyan tartja. A játékosok bábuinak száma játékosonként legfeljebb 20 lehet. A tábla 125 mezőből áll, az egy lépésben elérhető mezők számára tehát elméleti felső korlát a 124. A bábuk által egy lépésben elérhető mezők száma azonban ennél jóval kevesebb: az üres tábla közepére (Cc3 mező) helyezve a gyalog 7, a huszár 24, a bástya mindössze 12 (!), az unikornis 16, a futó 24, a vezér (= bástya + unikornis + futó) 52, a király 26 mezőre léphet. Mivel a játszma során minél több bábu van a táblán, egymás mozgását annál inkább korlátozzák, a valós műveletigény jelentősen tovább csökken. 
	
	A {\tt canMove} műveletigényének vizsgálata kapcsán érdekesség, hogy a hagyományos sakk játszása során egy matt megállapítása hasonlóan műveletigényes feladat: meg kell vizsgálni, hogy a játékos bármely bábujával, a bábu bármely lehetséges lépésével létre tud-e hozni olyan helyzetet, amelyben a másik játékos egyik bábujával sem támadja a királyt. Ezt a vizsgálatot az emberi agy látszólag figyelemre méltó sebességgel képes végrehajtani, azonban ehhez szinte bizonyosan heurisztikákat használ, hiszen tapasztalt sakkozók között is időről időre előfordul egy játszma során "meglepő" matt.
\end{itemize}

\subsubsection{A Game osztály}

A Game osztály a Model legfelső szintű osztálya, és egy Térsakk játszma teljes számítógépes reprezentálását biztosítja. A Game osztály ehhez három fő osztálynak delegál feladatokat:
\begin{itemize}
	\item a Board osztály biztosítja a tábla és az azon elhelyezkedő bábuk belső reprezentációját,
	\item a History osztály biztosítja a játszmatörténetet, azaz a játszma lépéseinek rögzítését,
	\item a Judge osztály biztosítja a szabályok betartását.
\end{itemize}
Mivel ezek a funkciók kölcsönösen összefüggenek, mindhárom osztály közvetlen vagy közvetett módon kommunikál egymással.

A Game osztály megvalósítja az IGameInfo interfészt, amelyen keresztül a játszma állapotáról információ kérhető:
\begin{itemize}
	\item a {\tt getGameState} metódus a játszma aktuális állapotát adja eredményül, a megjelenítő általi közvetlen felhasználás céljára. Ez tartalmazza többek között a bábuk elhelyezkedését a táblán;
	\item a {\tt getCurrentlyPossibleMovesFrom} metódus megadja, hogy az aktuális játékos egy adott mezőről mely más mezőkre léphet;
	\item a {\tt getNextPlayer} metódus megadja a lépésre következő játékost;
	\item a {\tt getBoard}, {\tt getHistory}, {\tt getJudge} metódusok segítségével kérhetjük le az adott alegységet megvalósító objektomokat\footnote{Megjegyzés: mivel az IGameInfo interfész viszonylag későn került bevezetésre, jelenleg ezek a metódusai nem biztosítják az adott alegység konstansként való kezelését. Ennek biztosítása a továbbfejlesztés egyik első lépése kell legyen.}.
\end{itemize}

A Vezérlő osztályai a Game osztály {\tt move} metódusával kezdeményezhetnek lépéseket, illetve a {\tt stepForward, stepBackward} metódusokkal lehetőség van előre és hátra lépkedni a játszmatörténetben. A játszmák elmentését illetve betöltését a folyamokon felüldefiniált $<<$ és $>>$ operátorok biztosítják.

\subsubsection{A GameState, a FullBoard és a Field struktúrák}

A program fejlesztése során először a Modell egy kezdeti megvalósítását készítettem el, amihez "karakteres" nézet tartozott. Ebben a kezdeti modellben még nem szerepelt sem játszmatörténet, sem lépésellenőrzés, ellenben a játszma aktuális állapotát egy GameState struktúra írta le. Ehhez a kezdeti Modellhez készült a Nézetet megvalósító Render2D modul, amely egy GameState struktúra alapján készíti el a megjelenítendő grafikus képet. Később a Modell jelentős újratervezésre és átdolgozásra került, a játszma belső állapotát immár a Game, a Board és a History osztályok együttműködő példányai reprezentálják. Hogy ne kelljen a már elkészült Render2D modult jelentősen átalakítani, az új Game osztály rendelkezik egy {\tt getGameState} metódussal, amely a Modell állapotát egy GameState struktúrába kinyeri.

A GameState struktúra tartalmazza a soron következő játékost, valamint egy FullBoard struktúrát. A FullBoard strúktúra a táblát leíró struktúra, és három egymásba ágyazott std::vector-ból áll, amelyek a tábla három tengelyét reprezentálják. A FullBoard struktúra a tábla egyes mezőit Field struktúrákkal írja le. A Field struktúra megadja a játékost (Player, ami felveheti a Nobody értéket is), a mezőn álló figurát (Figure, ami felveheti a None értéket is), és egy Position objektumot, amely megadja, hogy a mező hol helyezkedik el a táblán belül. A FullBoard struktúra továbbá tartalmaz egy {\tt at} függvényt, amely egy pozíciót kapva paraméterként visszaadja a pozícióhoz tartozó Field objektumot. Az {\tt at} művelet a szabvány könyvtár {\tt at} műveleteihez hasonlóan kivételt vált ki, ha a pozíció a táblán kívülre esik.

A GameState, FullBoard és Field struktúrákhoz tartozik $<<$ és $>>$ operátor, melyeket a korábbi karakteres megjelenítés során alkalmaztam. Ezeket az operátorokat jelenleg a program nem használja.

\subsection{A megjelenítés}

A Nézet osztályait a View névtér tartalmazza.

\subsubsection{A Render2D osztály}

A Nézet osztályait a Render2D osztály fogja össze. A nézet az IGameInfo interfészen keresztül ismeri a Game osztály egy példányát, amelytől a játszma aktuális állapotát igény ({\tt update} metódus) esetén lekéri. Megjelenítésre kerül a tábla (BoardPainter osztály), illetve további információk a játékról (PanelPainter osztály). A Nézet meg tudja állapítani, hogy az egérmutató a tábla mely része fölött tartózkodik ({\tt setAndGetBoardCursorFromScreenPosition} metódus), valamint hogy egy kattintás milyen megjelenített objektum fölött történt ({\tt handleClick} metódus). A mutatóeszköz kezelését azonban nem a Nézet végzi, hanem a Vezérlőtől kapja meg a mutatóeszköz koordinátáit. A Render2D osztály a Vezérlővel való kommunikációhoz megkapja a Vezérlő EventQueue objektumát.

A Render2D osztály a {\tt setSelectedField}, {\tt clearSelectedField}, {\tt setHighlightedFields} és {\tt clearHighlightedFields} műveleteket kínálja a Vezérlő számára, melyekkel a lépni kívánó bábu mezője, valamint a bábu által szabályszerűen elérhető mezők kiemelhetőek, illetve a kiemelések megszüntethetőek. A {\tt setMessage} metódus segítségével megadható egy sztring, amelyet a Nézet megjelenít. A {\tt setLocalPlayers} metódusnak hálózati játéknál van szerepe, ez biztosítja, hogy a Nézet csak akkor kezelje a mutatóeszköz műveleteit, amikor a helyi játékos van soron.

A Render2D osztály tartalmaz még egy StyleSheet struktúrát is.

\subsubsection{A StyleSheet struktúra}

A grafikus megjelenítés részleteit (színeket, méreteket, textúrákat) a StyleSheet struktúrája tartalmazza. Az összes megjelenítő alegység kap egy mutatót a StyleSheet struktúrára, amelyből csak egyetlen példány keletkezik a Nézetben. A StyleSheet struktúra létrehozza a bábuk képét tartalmazó textúrákat, és biztosít egy {\tt getPieceFor} műveletet, amellyel ezek lekérhetőek. A StyleSheet biztosítja a szövegek megjelenítéséhez a betűtípust, valamint a tábla szélén megjelenő annotáció karaktereit. A megjelenítendő kép dimenzióit és színeit konstansok segítségével definiálja. 

\subsubsection{A BoardPainter osztály}

A BoardPainter osztály felelős a tábla megjelenítéséért ({\tt draw} metódus). A megjelenítéshez a játszma állapotát az IGameInfo interfészen keresztül kéri le. Tovább módosítják a megjelenítést a {\tt setSelectedField} és {\tt setHighlightedFields} metódusok, melyekkel egyes mezőket különböző színekkel kiemelhetünk.

Ezen túl a BoardPainter alkalmas arra, hogy meghatározza, egy adott képernyőpozíció a játéktábla mely mezőjére esik ({\tt getFieldPositionFromScreenPosition} és {\tt setAndGetBoardCursorFromScreenPosition} metódusok). A {\tt handleClick} metódus segítségével - ha a tábla egy mezője fölött van az egérmutató - a BoardPainter üzenetben elküldi a Vezérlőnek a kiválasztott mező táblabeli pozícióját.

A rajzoláshoz a BoardPainter a View névtér \textbf{Field} osztályát hívja segítségül. A Field osztály az SFML absztrakt sf::Drawable osztályának leszármazottja, így az SFML grafikus motorja közvetlenül meg tudja jeleníteni ({\tt draw} metódus). Egy Field objektum a megjelenítéséhez szükséges összes információt tartalmazza. Konstruktorban kapja meg a Modell azon Field struktúráját, amelynek tartalmát megjeleníti. Amennyiben a mezőn bábu áll, a bábunak megfelelő textúra is kirajzolásra kerül. A {\tt setUnderCursor}, {\tt setTouched}, {\tt setHighlighted} metódusokkal beállíthatóak különböző kiemelések. A statikus, logikai {\tt isWhiteField} függvény megmondja, hogy egy adott táblabeli pozíció világos vagy sötét színezésű. A mező kirajzolása mindezek figyelembevételével történik. A {\tt getPosition} és {\tt getBoundaries} függvények az egérmutató táblabeli helyzetének meghatározásához nyújtanak segítséget.

A BoardPainter osztály {\tt draw} metódusának algoritumusa a következő: a program szintenként, soronként és oszloponként végighalad a táblán, és egy std::vector-ban (drawableFields) minden egyes mezőhöz létrehoz egy Field objektumot, amelyet a megfelelő képernyő-koordinátákkal felparaméterez. A {\tt draw} eközben kirajzolja a tábla körül megjelenő, a mezők azonosítását szolgáló tájékoztató jeleket is. Ezután a drawableFields objektumain szűrőszerűen többször végighalad, és azok {\tt setUnderCursor}, {\tt setTouched} és {\tt setHighlighted} metódusaival a megfelelő helyeken alkalmazza a kiemeléseket rajtuk. Végül az összes mezőre alkalmazza annak megvalósított {\tt draw} metódusát. A BoardPainter a rajzolási műveletek kisebb részekre bontásához több privát metódust is használ ({\tt buildPlane}, {\tt buildRow}, {\tt drawPlaneDecoration}, {\tt drawRowDecoration}), és az ezek közötti kommunikációhoz egyfajta állapotgépet valósít meg (currentPlane, currentRow, currentColumn változók). Ez a megközelítés inkább a struktúrált, mintsem az objektumorientált szemléletet követi.

\subsubsection{A PanelPainter osztály, a Widget és leszármazottai}

A PanelPainter osztály a képernyőn különböző információk megjelenítésére használható. Az információk megjelenítését az absztrakt Widget osztály leszármazottai biztosítják. A Widget az SFML sf::Drawable osztályát kibővíti saját pozíciójának, méreteinek, valamint a megjelenítést befolyásoló StyleSheet objektumnak ismeretével. A PanelPainter tartalmaz egy Widgetekből álló konténert, és a {\tt draw} eljárás hívására az abban található Widgeteket kirajzolja. A konténert a (privát) {\tt buildPanel} eljárás állítja össze. Emiatt a megoldás miatt (sajnos) a PanelPainter egyfajta közvetítőként működik a Modell állapotinformációi és a különféle Widgetek között.

A Widget osztálynak a következő leszármazottjai készültek el:
\begin{itemize}
	\item a CursorInfo tájékoztatást ad arról, hogy az egérmutató a tábla mely mezője fölött tartózkodik éppen;
	\item a MessageWidget egy std::string-et jelenít meg a képernyőn;
	\item a NextPlayerInfo kiírja a következő játékost, valamint hálózati játék esetén tájékoztatást ad arról, hogy a helyi játékos világossal vagy sötéttel játszik.
\end{itemize}

A PanelPainter osztály fel van készítve arra, hogy megállapítsa, egy mutatóesemény melyik Widget fölött következett be ({\tt getRect} és {\tt handleClick} metódusok). Ezt a funkciót a program jelenleg nem használja.

\section{A tesztelés}

A tesztelést két fronton végeztem. A használati esetek viszonylag kis száma folytán az integrációs tesztek elvégzését a program kézi kipróbálása jelentette. Ez magába foglalta a felhasználói felület tesztelését (kijelölés, kijelölés törlése, a lépési lehetőségek megjelenítésének ellenőrzése, a lépés, a tábla különböző színezéseinek ellenőrzése, az információs panel információtartalmának ellenőrzése), a hálózati játék tesztelését (csatlakozás különböző hálózati portokon, a lépések sorrendjének biztosítása, a hálózati kommunikáció eredményessége, kapcsolat elvesztése), valamint a szándékosan hibát eredményező helyzetek tesztelését (hiányzó állományok).

A tesztelés izgalmasabb részét a Modell automatikus tesztelése jelentette. A Modell elemi részeit (Position, a Piece leszármazottjai, Board, History) részletes, minden nem triviális metódusra kiterjedő egységtesztekkel vizsgáltam. A History teszteléséhez létrehoztam egy MockGameEvent osztályt, amely az absztrakt GameEvent leszármazottja, és a GameEvent osztály funkciótól független működését szimulálja. A tesztelés során 15 tesztesetben 118 vizsgálat történik. A fejlesztés során az egységtesztek sikeres futtatása biztosította, hogy az alacsonyabb szinten lévő osztályok működése felől biztonságban érezhettem magam. Ez óriási segítség volt a refaktorálás során, mivel megbizonyosodhattam róla, hogy az egyes osztályok a refaktorálás után is ugyanúgy ellátják feladataikat, mint előtte. Feltehetően az egységteszteknek köszönhetem, hogy a magasabb szintű funkciók megvalósítása során csak kevés időt kellett a debugger használatával töltenem.

\section{Továbbfejlesztési lehetőségek}

A program folyamatos iterált fejlesztés eredménye. Ennek következtében a korábban érthető, célszerű, megfelelő struktúrák időről időre egyre kevésbé maradtak érthetőek és célszerűek. A szoftver jelenlegi formájában a kitűzött célokat megvalósítja, azonban bármilyen komolyabb továbbfejlesztés előtt alapos refaktorálást igényel.

A refaktorálást a tesztek átdolgozásával kezdeném. Egyelőre csak a Modell osztályaihoz tartoznak egységtesztek, ezt célszerűnek látom egyrészt felfrissíteni, másrészt a Vezérlő modul osztályaira kiterjeszteni. Sajnos a Nézet általános működése jellegénél fogva nehezen tesztelhető automatikus eszközökkel, azonban ahol összetettebb funkció van megvalósítva, ott a Nézet elemeihez is célszerű egységteszteket készíteni.

A tesztlefedettség alapos kiterjesztése után megnyílik a lehetőség a szerkezeti refaktorálásra. Érzésem szerint a Vezérlő osztályaira kisebb tisztázás vár. Sokkal jelentősebb fejlesztési lehetőségek akadnak a Nézeten belül. Ami a 2D megjelenítőt illeti, célszerűnek látnám egy erősebben objektum-orientált szemlélet alkalmazását. Logikailag a BoardPainter osztály funkciója (egy bizonyos információ közvetítése a játszma állapotáról) beleillik a Widget osztály feladataiba. Másrészt a Widget osztály leszármazottjait erőteljesen függetleníteném a PanelPainter osztálytól, és a Vezérlővel való kommunikácót sokkal jobban a belső üzenetküldő szolgálat (jelenleg EventQueue) funkcióira bíznám. Amennyiben a megjelenített Nézet elemei jobban kihasználnák az objektum-orientált programozás előnyeit, megnyílna a lehetőség az ablak dinamikus átméretezése illetve a különböző képfelbontásokban hasonló eredményt adó teljes képernyős megjelenítés előtt. A Widget osztály további leszármazottja lehet egy Button osztály, amellyel különböző funkciók válnának kezdeményezhetővé a felhasználói felületről.

A hálózati játék menetébe illeszthető a játékosok egymás közötti kommunikációja (chat), a játék feladásának, döntetlen felajánlásának lehetősége. Növelheti a játék érdekességét, ha időkorlátokat vezetünk be. Hosszabb távon gondolkodva a játék kiegészíthető egy játszmaszervező webes szolgáltatással.

A Vezérlő kiegészíthető lehet mesterséges intelligencia vezérelte játékossal. A Modell jelenlegi funkciói némileg megalapozzák egy gyengébben játszó MI elkészítését.

A grafikai megjelenítés igazi forradalmát hozhatja, ha három dimenziós grafikát kezdünk használni. Mivel a programban a Modell és a Vezérlő erősen el van határolva a Nézettől, előbbi kettő minimális változtatásával megvalósítható egy 3D megjelenítés. A 3D megjelenítés implementálásához feltehetően célszerű valamilyen nyílt forrású 3D motort igénybe venni.

Végül, ha sikerül 3D megjelenítést implementálni, nincs semmi akadálya annak, hogy a képernyőn egymás mellé helyezzünk 5 darab 3D megjelenítőt. Ezzel a technikával játszhatóvá válhat egy új játék, a sakk 4 dimenziós kiterjesztése. Ebben a játékban a játszma egy $5 \times 5 \times 5 \times 5$ mezőből álló hiperkocka alkotta táblán játszódik... 

\begin{thebibliography}{CMake}
	\bibitem[Catch]{catch} Catch, github.com/philsquared/Catch, 2015.02.01
			
	\bibitem[CC]{cleancode} Robert C. Martin: Tiszta Kód, Kiskapu, 2010, [466], ISBN 978-963-9637-69-6

	\bibitem[CMake]{cmake} CMake, www.cmake.org, 2014.12.01.
	
	\bibitem[CppC]{codingrules} Andrei Alexandrescu, Herb Sutter: C++ kódolási szabályok, Kiskapu, 2005, [223], ISBN 963-9301-93-0
	
	\bibitem[Eff]{effective} Scott Meyers: Hatékony C++, Scolar, 2003, [272], ISBN 978-963-9193-82-6
	
	\bibitem[GoF]{designpatterns} Erich Gamma, Richard Helm, Ralph Johnson, John Vlissides: Design Patterns, Addison-Wesley, 1995, [395], ISBN 0-201-63361-2
	
	\bibitem[RAII]{raii} Jan Haller: Why RAII rocks, bromeon, http://www.bromeon.ch/articles/raii.html, 2015.02.15.
	
	\bibitem[Raum]{chessvariants} Bruce Balden, Hans L. Bodlaender: Raumschach, The Chess Variant Pages, www.chessvariants.org/3d.dir/3d5.html, 2014.06.01.
		
	\bibitem[SFML]{sfml} Simple and Fast Multimedia Library, www.sfml-dev.org, 2014.12.01.
\end{thebibliography}

\end{document}          
